{% extends "unified_base.html" %}
{% comment %}
Phase 3: Template Migration
Migrated from base.html to unified_base.html
Date: August 27, 2025
{% endcomment %}

{% block title %}Preview & Answer Keys - {{ exam.name }} - PrimePath{% endblock %}

{% block module_name %}placement_test{% endblock %}
{% block data_module %}placement_test{% endblock %}
{% block header_bg_color %}#1B5E20{% endblock %}

{% block header %}{{ exam.name }} - Preview & Answer Keys{% endblock %}

{% block extra_css %}
<style>
    .container-main {
        max-width: 1600px;
        margin: 0 auto;
        padding: 15px;
    }
    
    /* Create unified card appearance */
    .exam-wrapper {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        overflow: hidden;
    }
    
    .exam-info-bar {
        background-color: #f8f9fa;
        padding: 15px 20px;
        border-radius: 8px 8px 0 0;
        margin-bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        border: 1px solid #dee2e6;
        border-bottom: none;
    }
    
    .info-items {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
    }
    
    .info-item {
        display: flex;
        flex-direction: column;
    }
    
    .info-label {
        font-size: 0.85rem;
        color: #6c757d;
        margin-bottom: 2px;
    }
    
    .info-value {
        font-size: 1.1rem;
        font-weight: 500;
        color: #212529;
    }
    
    .status-active {
        color: #28a745;
    }
    
    .status-inactive {
        color: #dc3545;
    }
    
    .pdf-title-section {
        text-align: center;
        margin-bottom: 0;
        padding: 15px 0;
        background-color: #f0f4f8;
        border-radius: 8px 8px 0 0;
        border: 1px solid #dee2e6;
        border-bottom: 1px solid #e9ecef;
    }
    
    .pdf-title {
        font-size: 2.5rem;
        font-weight: 700;
        color: #2c3e50;
        margin: 0;
        word-break: break-word;
        line-height: 1.3;
    }
    
    /* Responsive Design for 8-18 year olds */
    
    /* Desktop optimizations (1024px+) */
    @media (min-width: 1024px) {
        .container-main {
            max-width: 1800px;
            padding: 25px;
        }
        
        .pdf-section {
            /* Removed fixed height to prevent gap */
            height: auto;
        }
        
        .pdf-title {
            font-size: 2.8rem;
        }
        
        .pdf-controls {
            background: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 0 !important;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .pdf-controls button {
            min-width: 110px;
            min-height: 44px;
            font-size: 1rem;
            padding: 10px 18px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        #pdf-page-info {
            font-size: 1.1rem;
            font-weight: 500;
            margin: 0 30px;
        }
    }
    
    /* Tablet optimizations (768px to 1023px) */
    @media (min-width: 768px) and (max-width: 1023px) {
        .container-main {
            max-width: 100%;
            padding: 20px 15px;
        }
        
        .pdf-section {
            /* Removed min-height to prevent gap */
            height: auto;
            max-height: 75vh;
        }
        
        .pdf-title {
            font-size: 2.2rem;
        }
        
        .pdf-controls {
            background: #fff;
            padding: 12px 18px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .pdf-controls button {
            min-width: 95px;
            min-height: 44px;
            font-size: 0.95rem;
            padding: 10px 16px;
            border-radius: 6px;
            touch-action: manipulation;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        #pdf-page-info {
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            flex: 1;
        }
    }
    
    /* Touch-friendly improvements for all sizes */
    .pdf-controls button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .pdf-controls button:active {
        transform: translateY(0);
        transition: all 0.1s ease;
    }
    
    .pdf-controls button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        background-color: #e9ecef !important;
        border-color: #dee2e6 !important;
        color: #6c757d !important;
    }
    
    /* Removed complex PDF canvas styles - using browser-native display */
    
    /* Responsive navigation layout */
    @media (max-width: 767px) {
        .pdf-controls {
            flex-direction: column;
            gap: 10px;
        }
        
        .pdf-controls > div {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        
        .pdf-navigation {
            margin: 0;
        }
    }
    
    .main-content {
        display: flex;
        flex-direction: column;
        gap: 0;
        background: white;
        border-radius: 0 0 8px 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        overflow: hidden;
    }
    
    .pdf-section {
        background: white;
        border: none;
        border-top: 1px solid #dee2e6;
        border-radius: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        /* Removed min-height to eliminate gap */
        height: auto;
        max-height: 85vh;
        width: 100%;
    }
    
    .answers-section {
        background: white;
        border: none;
        border-top: 1px solid #dee2e6;
        border-radius: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        /* Removed min-height for consistency */
        width: 100%;
    }
    
    /* Last section gets bottom border radius */
    .main-content > *:last-child {
        border-radius: 0 0 8px 8px;
    }
    
    .audio-files-section {
        background: white;
        border: none;
        border-top: 1px solid #dee2e6;
        border-radius: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        width: 100%;
    }
    
    .audio-files-content {
        padding: 20px;
    }
    
    .audio-file-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 12px;
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        margin-bottom: 10px;
    }
    
    .audio-actions {
        display: flex;
        gap: 5px;
        align-items: center;
    }
    
    .rename-btn {
        padding: 2px 8px;
        font-size: 0.875rem;
    }
    
    .delete-btn {
        padding: 2px 8px;
        font-size: 0.875rem;
    }
    
    .audio-file-info {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .audio-file-name-input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 1rem;
    }
    
    
    .audio-player {
        width: 200px;
    }
    
    .audio-save-indicator {
        color: #28a745;
        font-size: 0.85rem;
        display: none;
    }
    
    .section-header {
        background-color: #f8f9fa;
        padding: 12px 20px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
    }
    
    .section-header::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background: linear-gradient(180deg, #007bff, #0056b3);
    }
    
    .section-title {
        font-size: 1.05rem;
        font-weight: 600;
        margin: 0;
        color: #2c3e50;
    }
    
    .pdf-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        margin: 0 !important;
    }
    
    .pdf-viewer {
        flex: 1;
        overflow: auto;
        text-align: center;
        background-color: #f5f5f5;
        padding: 10px 20px; /* Reduced vertical padding to minimize gap */
        display: flex;
        justify-content: center;
        align-items: flex-start;
    }
    
    .answers-content {
        flex: 1;
        overflow-y: auto;
        padding: 15px 20px;
        max-width: 1200px;
        margin: 0 auto;
        width: 100%;
    }
    
    .question-entry {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 20px;
        margin-bottom: 12px;
    }
    
    .question-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .question-number {
        font-weight: 600;
        color: #2c3e50;
        font-size: 1.1rem;
    }
    
    /* Points container moved to comprehensive fix section below */
    
    .question-points-display {
        background: #e3f2fd;
        color: #1976d2;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.85rem;
        font-weight: 500;
    }
    
    .question-points-edit {
        display: flex;
        align-items: center;
        gap: 5px;
        background: #f8f9fa;
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid #007bff;
    }
    
    .points-input {
        width: 60px;
        padding: 4px 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.9rem;
        text-align: center;
        font-weight: 600;
    }
    
    /* ENHANCED: More visible button styles */
    .edit-points-btn, .save-points-btn, .cancel-points-btn {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        font-size: 1rem;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s;
        margin-left: 4px;
        display: inline-block;
        vertical-align: middle;
    }
    
    .edit-points-btn {
        opacity: 1;
        background: #fff3cd;
        border-color: #ffc107;
        color: #856404;
    }
    
    .edit-points-btn:hover {
        opacity: 1;
        background: #ffc107;
        color: #fff;
        transform: scale(1.05);
    }
    
    /* ENHANCED: Points editing loading and feedback states */
    .question-points-edit.loading {
        opacity: 0.7;
        pointer-events: none;
    }
    
    .points-input:disabled {
        background: #f5f5f5;
        cursor: not-allowed;
    }
    
    .save-points-btn:disabled,
    .cancel-points-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* NEW: Impact preview tooltip */
    .points-impact-preview {
        position: absolute;
        z-index: 1000;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-size: 0.85rem;
        max-width: 300px;
        display: none;
        margin-top: 8px;
        margin-left: -150px;
    }
    
    .points-impact-preview.show {
        display: block;
    }
    
    .impact-preview-header {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 6px;
    }
    
    .impact-preview-stats {
        color: #666;
        line-height: 1.4;
    }
    
    .impact-sessions-count {
        color: #f39c12;
        font-weight: 500;
    }
    
    .impact-no-sessions {
        color: #27ae60;
        font-style: italic;
    }
    
    .impact-preview-loading {
        color: #999;
        font-style: italic;
    }
    
    /* ENHANCED: Save and cancel button styles */
    .save-points-btn {
        color: #fff;
        background: #28a745;
        border-color: #28a745;
    }
    
    .save-points-btn:hover {
        background: #218838;
        border-color: #1e7e34;
        transform: scale(1.05);
    }
    
    .cancel-points-btn {
        color: #fff;
        background: #dc3545;
        border-color: #dc3545;
    }
    
    .cancel-points-btn:hover {
        background: #c82333;
        border-color: #bd2130;
        transform: scale(1.05);
    }
    
    /* CRITICAL FIX: Ensure points editing buttons are visible */
    .question-points-container .edit-points-btn {
        display: inline-block !important;
        visibility: visible !important;
    }
    
    .question-points-container .question-points-edit {
        align-items: center;
    }
    
    /* Ensure proper layout in container */
    .question-points-container {
        display: flex;
        align-items: center;
        gap: 8px;
        min-height: 32px;
    }
    
    .question-controls {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 15px;
        margin-bottom: 12px;
    }
    
    .type-selector {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    .type-selector label {
        font-size: 0.9rem;
        color: #495057;
        margin: 0;
    }
    
    .type-selector select {
        padding: 6px 12px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    
    /* MCQ Options Container - Improved UI */
    .mcq-options-container {
        display: flex;
        gap: 20px;
        margin-top: 15px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
    }
    
    .mcq-control-group {
        flex: 1;
        padding: 12px;
        background: white;
        border-radius: 6px;
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
    }
    
    .mcq-control-group:hover {
        border-color: #4CAF50;
        box-shadow: 0 2px 4px rgba(76, 175, 80, 0.1);
    }
    
    .answer-choices-group {
        border-left: 3px solid #2196F3;
    }
    
    .answer-type-group {
        border-left: 3px solid #FF9800;
    }
    
    .control-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .control-icon {
        font-size: 1.2rem;
    }
    
    .control-header label {
        font-weight: 600;
        color: #2c3e50;
        font-size: 0.95rem;
        margin: 0;
        cursor: pointer;
    }
    
    .control-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .options-input {
        width: 80px;
        padding: 6px 10px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.95rem;
        text-align: center;
    }
    
    .options-input:focus {
        border-color: #2196F3;
        outline: none;
        box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1);
    }
    
    .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 5px 0;
    }
    
    .checkbox-wrapper input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #FF9800;
    }
    
    .checkbox-label {
        font-size: 0.95rem;
        color: #333;
        user-select: none;
    }
    
    .help-text {
        font-size: 0.85rem;
        color: #6c757d;
        font-style: italic;
        margin-top: 4px;
        line-height: 1.3;
    }
    
    /* MIXED question options container */
    .mixed-options-container {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
    }
    
    .mixed-choices-group {
        flex: 2;
        border-left: 3px solid #9C27B0;
    }
    
    .sub-label {
        font-size: 0.9rem;
        color: #495057;
        display: block;
        margin-bottom: 5px;
    }
    
    .info-note {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        background: #fff3cd;
        border: 1px solid #ffc107;
        border-radius: 6px;
        font-size: 0.9rem;
        color: #856404;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .mcq-options-container,
        .mixed-options-container {
            flex-direction: column;
            gap: 12px;
        }
        
        .mcq-control-group,
        .info-note {
            width: 100%;
        }
    }
    
    /* Legacy selector for compatibility */
    .options-count-selector {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
    }
    
    .options-count-selector input {
        width: 50px;
        padding: 4px 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    
    /* Mixed question type styles */
    .mixed-answer-section {
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 12px;
        background: #fbfcfd;
    }
    
    .mixed-type-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .mixed-type-label {
        font-weight: 600;
        color: #495057;
        font-size: 0.95rem;
    }
    
    .remove-section-btn {
        padding: 4px 10px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
    }
    
    .add-section-btn {
        padding: 8px 16px;
        background: #17a2b8;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        margin-top: 10px;
    }
    
    .add-section-btn:hover {
        background: #138496;
    }
    
    .audio-button {
        padding: 6px 15px;
        font-size: 0.85rem;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 200px;
    }
    
    .audio-button:hover {
        background: #e9ecef;
    }
    
    .audio-button.has-audio {
        background: #d1ecf1;
        border-color: #bee5eb;
        color: #0c5460;
    }
    
    .answer-input-group {
        display: flex;
        gap: 10px;
        align-items: flex-start;
    }
    
    .answer-input {
        flex: 1;
    }
    
    .answer-input input, 
    .answer-input textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 1rem;
        font-family: inherit;
    }
    
    .answer-input textarea {
        min-height: 80px;
        resize: vertical;
    }
    
    .answer-help {
        font-size: 0.8rem;
        color: #6c757d;
        margin-top: 4px;
    }
    
    /* Multiple choice buttons */
    .mcq-options {
        display: flex;
        gap: 15px;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }
    
    .mcq-button {
        width: 55px;
        height: 55px;
        border: 2px solid #dee2e6;
        background: white;
        border-radius: 8px;
        font-size: 1.3rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .mcq-button:hover {
        background: #f8f9fa;
        border-color: #adb5bd;
    }
    
    .mcq-button.selected {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }
    
    .mcq-button.selected:hover {
        background: #0056b3;
        border-color: #0056b3;
    }
    
    /* Checkbox options */
    .checkbox-options {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin-bottom: 10px;
    }
    
    .checkbox-option {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .checkbox-option input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
    }
    
    .checkbox-option label {
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        margin: 0;
    }
    
    /* Short answer responses */
    .short-answer-responses {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .response-item {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    
    .response-item input {
        flex: 1;
        padding: 6px 10px;
        border: 1px solid #ced4da;
        border-radius: 4px;
    }
    
    .remove-response {
        padding: 4px 8px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
    }
    
    .remove-response:hover {
        background: #c82333;
    }
    
    .add-response {
        align-self: flex-start;
        padding: 6px 12px;
        background: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        margin-top: 8px;
    }
    
    .add-response:hover {
        background: #218838;
    }
    
    .save-indicator {
        color: #28a745;
        font-size: 0.85rem;
        display: none;
    }
    
    .audio-section {
        background-color: #f0f8ff;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    .audio-item {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 10px;
    }
    
    .audio-label {
        font-weight: 500;
        min-width: 150px;
    }
    
    .save-all-section {
        position: sticky;
        bottom: 0;
        background: white;
        border-top: 2px solid #dee2e6;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .unsaved-indicator {
        color: #ffc107;
        display: none;
    }
    
    .action-buttons {
        display: flex;
        gap: 10px;
    }
    
    /* Responsive */
    @media (max-width: 1200px) {
        .pdf-section {
            /* Removed fixed height to prevent gap */
            height: auto;
        }
        
        .answers-content {
            padding: 20px;
        }
    }
    
    /* PDF Canvas Styles - Enhanced for better display */
    .pdf-viewer {
        flex: 1;
        overflow: auto;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 10px 20px; /* Reduced vertical padding */
        /* Removed min-height to eliminate gap */
    }
    
    /* Removed complex PDF canvas styles - using browser-native display */
    
    .pdf-navigation {
        margin: 0 15px;
        font-size: 1rem;
        font-weight: 500;
        color: #495057;
        white-space: nowrap;
    }
    
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .zoom-level {
        min-width: 50px;
        text-align: center;
        font-weight: 500;
        font-size: 0.9rem;
        color: #495057;
    }
    
    .pdf-controls .btn-sm {
        min-width: 35px;
        min-height: 35px;
        padding: 6px 8px;
        font-size: 1.1rem;
        font-weight: 600;
    }
    
    .zoom-controls {
        display: flex;
        gap: 5px;
        align-items: center;
    }
    
    .zoom-level {
        min-width: 50px;
        text-align: center;
        font-size: 0.9rem;
    }
    
    /* Success notification animations */
    @keyframes slideDown {
        from {
            transform: translateX(-50%) translateY(-100%);
            opacity: 0;
        }
        to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    }
    
    @keyframes pulse {
        0%, 100% {
            transform: translateX(-50%) scale(1);
        }
        50% {
            transform: translateX(-50%) scale(1.02);
        }
    }
    
    /* NOTIFICATION SYSTEM STYLES */
    .notification-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100000;
        pointer-events: none;
        max-width: 400px;
        width: calc(100% - 40px);
    }
    
    .notification-item {
        pointer-events: auto;
        margin-bottom: 10px;
        padding: 12px 20px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: space-between;
        animation: slideInRight 0.3s ease-out;
        position: relative;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        font-size: 14px;
        line-height: 1.4;
    }
    
    .notification-item.success {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
        border-left: 4px solid #28a745;
    }
    
    .notification-item.error {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c2c7 100%);
        color: #721c24;
        border-left: 4px solid #dc3545;
    }
    
    .notification-item.info {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
        border-left: 4px solid #17a2b8;
    }
    
    .notification-item.warning {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
        border-left: 4px solid #ffc107;
    }
    
    .notification-message {
        flex: 1;
        margin-right: 10px;
        font-weight: 500;
    }
    
    .notification-close {
        background: none;
        border: none;
        color: inherit;
        opacity: 0.7;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
    }
    
    .notification-close:hover {
        opacity: 1;
    }
    
    .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 3px;
        background: rgba(0, 0, 0, 0.2);
        animation: progress 5s linear forwards;
        transform-origin: left;
    }
    
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
    
    @keyframes progress {
        from {
            transform: scaleX(1);
        }
        to {
            transform: scaleX(0);
        }
    }
    
    .notification-item.removing {
        animation: slideOutRight 0.3s ease-out forwards;
    }
</style>
{% endblock %}

{% block main %}
{% csrf_token %}
<!-- Success Notification Container -->
<div id="success-notification" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; min-width: 400px;">
    <div class="alert alert-success" style="margin: 0; padding: 12px 20px; font-size: 1rem; font-weight: 600; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.2); background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-left: 4px solid #28a745; position: relative;">
        <button type="button" class="close-alert" onclick="document.getElementById('success-notification').style.display='none'" style="float: right; background: none; border: none; font-size: 1.3rem; cursor: pointer; color: inherit; margin-left: 15px;">&times;</button>
        <span id="success-message">All answers saved successfully!</span>
        <span style="position: absolute; right: 45px; top: 50%; transform: translateY(-50%); font-size: 1.2rem;">‚úì</span>
    </div>
</div>
<div class="container-main">
    <!-- PDF Title -->
    <div class="pdf-title-section">
        <h1 class="pdf-title">
            {{ exam.name }}
        </h1>
    </div>
    
    <!-- Unified Card Wrapper -->
    <div class="exam-wrapper">
        <!-- Exam Info Bar -->
        <div class="exam-info-bar">
            <div class="info-items">
                <div class="info-item">
                    <span class="info-label">Duration</span>
                    <span class="info-value">{{ exam.timer_minutes }} min</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Questions</span>
                    <span class="info-value">{{ exam.total_questions }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Status</span>
                    <span class="info-value {% if exam.is_active %}status-active{% else %}status-inactive{% endif %}">
                        {% if exam.is_active %}Active{% else %}Inactive{% endif %}
                    </span>
                </div>
                <div class="info-item">
                    <span class="info-label">Created</span>
                    <span class="info-value">{{ exam.created_at|date:"M d, Y" }}</span>
                </div>
            </div>
            <a href="{% url 'PlacementTest:exam_list' %}" class="btn btn-secondary btn-sm">Back to List</a>
        </div>
        
        <!-- Main Content Grid -->
        <div class="main-content">
        <!-- PDF Preview Section -->
        <div class="pdf-section">
            <div class="section-header">
                <h3 class="section-title">PDF Preview</h3>
                <!-- Unified PDF Control Bar -->
                <div class="pdf-controls" style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; justify-content: center; padding: 10px; background: #f8f9fa; border-radius: 6px; margin: 0;">
                    <!-- Navigation Group -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                        <button type="button" id="pdf-prev" class="btn btn-primary" disabled>
                            <span class="d-none d-md-inline">‚Üê Previous</span>
                            <span class="d-md-none">‚Üê</span>
                        </button>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span>Page</span>
                            <input type="number" id="pdf-page-input" value="1" min="1" max="1" 
                                   style="width: 60px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                            <span>of <span id="total-pages">1</span></span>
                        </div>
                        <button type="button" id="pdf-next" class="btn btn-primary">
                            <span class="d-none d-md-inline">Next ‚Üí</span>
                            <span class="d-md-none">‚Üí</span>
                        </button>
                    </div>
                    
                    <!-- Divider -->
                    <div class="control-divider" style="width: 1px; height: 30px; background: #dee2e6;"></div>
                    
                    <!-- Rotation Group -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                        <button type="button" id="pdf-rotate-left" class="btn btn-secondary" title="Rotate Left">
                            <span>‚Ü∫ Rotate</span>
                        </button>
                        <button type="button" id="pdf-rotate-right" class="btn btn-secondary" title="Rotate Right">
                            <span>Rotate ‚Üª</span>
                        </button>
                    </div>
                    
                    <!-- Divider -->
                    <div class="control-divider" style="width: 1px; height: 30px; background: #dee2e6;"></div>
                    
                    <!-- Zoom Group -->
                    <div class="control-group zoom-controls" style="display: flex; align-items: center; gap: 10px;">
                        <button type="button" id="pdf-zoom-out" class="btn btn-sm btn-outline-secondary">‚àí</button>
                        <span class="zoom-level" id="pdf-zoom-level">100%</span>
                        <button type="button" id="pdf-zoom-in" class="btn btn-sm btn-outline-secondary">+</button>
                    </div>
                    
                    <!-- Divider -->
                    <div class="control-divider" style="width: 1px; height: 30px; background: #dee2e6;"></div>
                    
                    <!-- Quick Jump Group -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                        <label for="pdf-jump-input" style="margin: 0;">Go to:</label>
                        <input type="number" id="pdf-jump-input" placeholder="Page #" min="1" 
                               style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                        <button type="button" id="pdf-jump-btn" class="btn btn-info">
                            <span>üîç Go</span>
                        </button>
                    </div>
                </div>
                    <!-- Skip First Left Half Status (Read-only) - REMOVED FEATURE -->
                    {% comment %}{% if false %}
                    <div class="skip-status" style="margin-left: 15px; border-left: 1px solid #dee2e6; padding-left: 15px;">
                        <span style="font-size: 0.875rem; color: #6c757d;">
                            <i class="fas fa-eye-slash" style="margin-right: 5px;"></i>
                            First Page (Left Half) Hidden
                        </span>
                        <small class="d-block" style="font-size: 0.75rem; color: #6c757d; margin-top: 2px;">
                            This setting was configured during exam upload
                        </small>
                    </div>
                    {% endif %}{% endcomment %}
                    {% if exam.pdf_file %}
                    <a href="{{ exam.pdf_file.url }}" class="btn btn-sm btn-primary" download>
                        Download PDF
                    </a>
                    {% else %}
                    <span class="text-muted">No PDF uploaded</span>
                    {% endif %}
                </div>
            </div>
            <div class="pdf-viewer" id="pdf-viewer">
                <!-- PDF Image Display -->
                <div id="pdf-image-display" style="width: 100%; height: 100%; position: relative;">
                    <div id="pdf-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10;">
                        <p>Loading PDF...</p>
                    </div>
                    <img id="pdf-page-image" style="width: 100%; height: 100%; object-fit: contain; background: white;" alt="PDF Page">
                    
                    <!-- Navigation Controls -->
                    <div id="pdf-nav-controls" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); border-radius: 25px; padding: 10px 15px; display: flex; align-items: center; gap: 15px;">
                        <button id="pdf-prev" class="btn btn-sm" style="background: #fff; border: none; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center;">‚Äπ</button>
                        <span id="pdf-page-info" style="color: white; font-weight: 500; min-width: 80px; text-align: center;">Page 1 of 1</span>
                        <button id="pdf-next" class="btn btn-sm" style="background: #fff; border: none; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center;">‚Ä∫</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Audio Files Management Section -->
        {% if exam.audio_files.exists %}
        <div class="audio-files-section">
            <div class="section-header">
                <h3 class="section-title">Audio Files</h3>
                <button type="button" class="btn btn-sm btn-success" onclick="saveAllAudioNames()">
                    Save Audio Names
                </button>
            </div>
            <div class="audio-files-content">
                {% for audio in exam.audio_files.all %}
                <div class="audio-file-item" data-audio-id="{{ audio.id }}" id="audio-item-{{ audio.id }}">
                    <div class="audio-file-info">
                        <input type="text" 
                               class="audio-file-name-input" 
                               id="audio-name-{{ audio.id }}"
                               value="{{ audio.name }}"
                               placeholder="Enter display name for this exam"
                               onchange="markAudioNameChanged({{ audio.id }})">
                        <span class="text-muted" style="font-size: 0.8rem; margin-left: 10px;">(Original: {{ audio.name }})</span>
                    </div>
                    <audio controls class="audio-player">
                        <source src="{% url 'PlacementTest:get_audio' audio.id %}" type="audio/mpeg">
                        Your browser does not support the audio element.
                    </audio>
                    <div class="audio-actions">
                        <button type="button" 
                                class="btn btn-sm btn-primary rename-btn" 
                                onclick="renameAudioFile({{ audio.id }})"
                                title="Rename this audio file">
                            Rename
                        </button>
                        <button type="button" 
                                class="btn btn-sm btn-danger delete-btn" 
                                onclick="deleteAudioFile({{ audio.id }})"
                                title="Remove this audio file from exam">
                            Delete
                        </button>
                    </div>
                    <span class="audio-save-indicator" id="audio-saved-{{ audio.id }}">‚úì Saved</span>
                </div>
                {% endfor %}
            </div>
        </div>
        {% endif %}
        
        <!-- Answer Keys Section -->
        <div class="answers-section">
            <div class="section-header">
                <h3 class="section-title">Answer Keys</h3>
                <div style="display: flex; gap: 10px;">
                    <button type="button" class="btn btn-sm btn-warning" onclick="randomizeAnswers()">
                        üé≤ Randomize for QA
                    </button>
                    <button type="button" class="btn btn-sm btn-success" onclick="saveAllAnswers()">
                        Save All
                    </button>
                </div>
            </div>
            <div class="answers-content">
                {% for question in questions %}
                <div class="question-entry" data-question-number="{{ question.question_number }}" data-question-id="{{ question.id }}">
                    <div class="question-header">
                        <span class="question-number">Question {{ question.question_number }}</span>
                        <div class="question-points-container">
                            <span class="question-points-display">{{ question.points }} point{% if question.points != 1 %}s{% endif %}</span>
                            <div class="question-points-edit" style="display: none;">
                                <input type="number" 
                                       class="points-input" 
                                       min="1" max="10" 
                                       value="{{ question.points }}"
                                       data-question-id="{{ question.id }}"
                                       data-original-value="{{ question.points }}">
                                <button class="save-points-btn" data-question-id="{{ question.id }}">‚úì</button>
                                <button class="cancel-points-btn" data-question-id="{{ question.id }}">‚úó</button>
                            </div>
                            <button class="edit-points-btn" data-question-id="{{ question.id }}" title="Edit points">‚úèÔ∏è</button>
                        </div>
                    </div>
                    
                    <div class="question-controls">
                        <div class="type-selector">
                            <label for="type-{{ question.question_number }}">Question Type:</label>
                            <select id="type-{{ question.question_number }}" 
                                    data-question="{{ question.question_number }}"
                                    class="question-type-select">
                                <option value="MCQ" {% if question.question_type == 'MCQ' or question.question_type == 'CHECKBOX' %}selected{% endif %}>Multiple Choice</option>
                                <option value="SHORT" {% if question.question_type == 'SHORT' %}selected{% endif %}>Short Answer</option>
                                <option value="LONG" {% if question.question_type == 'LONG' %}selected{% endif %}>Long Answer</option>
                                <option value="MIXED" {% if question.question_type == 'MIXED' %}selected{% endif %}>Mixed</option>
                            </select>
                            <div id="mcq-options-{{ question.question_number }}" class="mcq-options-container" style="{% if question.question_type != 'MCQ' and question.question_type != 'CHECKBOX' %}display:none;{% endif %}">
                                <!-- Answer Choices Settings -->
                                <div class="mcq-control-group answer-choices-group">
                                    <div class="control-header">
                                        <span class="control-icon">üìù</span>
                                        <label for="options-count-{{ question.question_number }}">Number of Answer Choices</label>
                                    </div>
                                    <div class="control-body">
                                        <input type="number" 
                                               id="options-count-{{ question.question_number }}"
                                               class="form-control options-input"
                                               value="{{ question.options_count|default:5 }}"
                                               min="2" max="10"
                                               onchange="updateOptionsCount({{ question.question_number }})">
                                        <span class="help-text">How many options (A, B, C, D...) to display</span>
                                    </div>
                                </div>
                                
                                <!-- Answer Type Settings -->
                                <div class="mcq-control-group answer-type-group">
                                    <div class="control-header">
                                        <span class="control-icon">‚úì</span>
                                        <label for="multi-{{ question.question_number }}">Answer Selection Type</label>
                                    </div>
                                    <div class="control-body">
                                        <label class="checkbox-wrapper">
                                            <input type="checkbox" 
                                                   id="multi-{{ question.question_number }}"
                                                   {% if question.question_type == 'CHECKBOX' or ',' in question.correct_answer %}checked{% endif %}
                                                   onchange="toggleMultipleAnswers({{ question.question_number }})">
                                            <span class="checkbox-label">Allow Multiple Correct Answers</span>
                                        </label>
                                        <span class="help-text">Students can select more than one answer</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button type="button" 
                                class="audio-button"
                                data-question="{{ question.question_number }}"
                                onclick="toggleAudio({{ question.question_number }})">
                            üéµ Audio
                        </button>
                    </div>
                    
                    <div class="answer-input-group">
                        <div class="answer-input" id="answer-container-{{ question.question_number }}">
                            {% if question.question_type == 'MCQ' or question.question_type == 'CHECKBOX' %}
                                {% with selected=question.correct_answer|upper %}
                                <div class="mcq-options" id="mcq-buttons-{{ question.question_number }}">
                                    {% for i in "ABCDEFGHIJ"|slice:question.options_count %}
                                        <button type="button" 
                                                class="mcq-button {% if i in selected %}selected{% endif %}"
                                                data-question="{{ question.question_number }}"
                                                data-value="{{ i }}"
                                                data-multiple="{% if question.question_type == 'CHECKBOX' or ',' in question.correct_answer %}true{% else %}false{% endif %}"
                                                onclick="selectMCQ({{ question.question_number }}, '{{ i }}')">
                                            {{ i }}
                                        </button>
                                    {% endfor %}
                                </div>
                                <input type="hidden" 
                                       id="answer-{{ question.question_number }}" 
                                       data-question="{{ question.question_number }}"
                                       value="{{ question.correct_answer }}"
                                       class="answer-field">
                                <div class="answer-help" id="mcq-help-{{ question.question_number }}">
                                    {% if question.question_type == 'CHECKBOX' or ',' in question.correct_answer %}
                                        Click to select correct answer(s) - multiple selections allowed
                                    {% else %}
                                        Click to select the correct answer
                                    {% endif %}
                                </div>
                                {% endwith %}
                            {% elif question.question_type == 'SHORT' %}
                                <div class="short-answer-responses" id="responses-{{ question.question_number }}">
                                    {% if question.response_list %}
                                        <!-- Use response_list when available (populated with saved values) -->
                                        {% for response in question.response_list %}
                                            <div class="response-item">
                                                <input type="text" 
                                                       value="{{ response }}"
                                                       placeholder="Acceptable response {{ forloop.counter }}"
                                                       onchange="updateShortAnswers({{ question.question_number }})">
                                                {% if not forloop.first %}
                                                    <button type="button" class="remove-response" onclick="removeResponse({{ question.question_number }}, this)">Remove</button>
                                                {% endif %}
                                            </div>
                                        {% endfor %}
                                    {% elif question.options_count and question.options_count > 1 %}
                                        <!-- Create empty fields if no saved values but multiple fields expected -->
                                        {% for i in "12345678910"|slice:question.options_count %}
                                            <div class="response-item">
                                                <input type="text" 
                                                       value=""
                                                       placeholder="Acceptable response {{ forloop.counter }}"
                                                       onchange="updateShortAnswers({{ question.question_number }})">
                                                {% if not forloop.first %}
                                                    <button type="button" class="remove-response" onclick="removeResponse({{ question.question_number }}, this)">Remove</button>
                                                {% endif %}
                                            </div>
                                        {% endfor %}
                                    {% else %}
                                        <!-- Single input field for SHORT answer when options_count is 0, 1, or null -->
                                        <div class="response-item">
                                            <input type="text" 
                                                   value="{{ question.correct_answer|default:'' }}"
                                                   placeholder="Enter the correct answer"
                                                   onchange="updateShortAnswers({{ question.question_number }})">
                                        </div>
                                    {% endif %}
                                </div>
                                <button type="button" class="add-response" onclick="addResponse({{ question.question_number }})">+ Add Response</button>
                                <input type="hidden" 
                                       id="answer-{{ question.question_number }}" 
                                       data-question="{{ question.question_number }}"
                                       value="{{ question.correct_answer }}"
                                       class="answer-field">
                                <div class="answer-help">Add multiple acceptable responses</div>
                            {% elif question.question_type == 'LONG' %}
                                <div class="short-answer-responses" id="responses-{{ question.question_number }}">
                                    {% if question.long_response_list %}
                                        {% for response in question.long_response_list %}
                                            <div class="response-item">
                                                <textarea placeholder="Grading guideline or sample answer {{ forloop.counter }}"
                                                          onchange="updateLongAnswers({{ question.question_number }})"
                                                          style="min-height: 80px; width: 100%;">{{ response }}</textarea>
                                                {% if not forloop.first %}
                                                    <button type="button" class="remove-response" onclick="removeResponse({{ question.question_number }}, this)">Remove</button>
                                                {% endif %}
                                            </div>
                                        {% endfor %}
                                    {% else %}
                                        <div class="response-item">
                                            <textarea placeholder="Grading guideline or sample answer 1"
                                                      onchange="updateLongAnswers({{ question.question_number }})"
                                                      style="min-height: 80px; width: 100%;">{{ question.correct_answer }}</textarea>
                                        </div>
                                    {% endif %}
                                </div>
                                <button type="button" class="add-response" onclick="addLongResponse({{ question.question_number }})">+ Add Grading Guideline</button>
                                <input type="hidden" 
                                       id="answer-{{ question.question_number }}" 
                                       data-question="{{ question.question_number }}"
                                       value="{{ question.correct_answer }}"
                                       class="answer-field">
                                <div class="answer-help">Add multiple grading guidelines or sample answers</div>
                            {% elif question.question_type == 'MIXED' %}
                                <!-- MCQ Options Count Selector for MIXED questions - Improved UI -->
                                <div class="mixed-options-container">
                                    <div class="mcq-control-group mixed-choices-group">
                                        <div class="control-header">
                                            <span class="control-icon">üî¢</span>
                                            <label for="mixed-options-count-{{ question.question_number }}">MCQ Component Settings</label>
                                        </div>
                                        <div class="control-body">
                                            <label class="sub-label">Number of MCQ Options:</label>
                                            <select class="form-control mixed-options-count-selector" name="mixed_options_count" 
                                                    data-question-id="{{ question.id }}" 
                                                    data-question-num="{{ question.question_number }}"
                                                    id="mixed-options-count-{{ question.question_number }}"
                                                    style="width: 100px;">
                                                {% for i in "2,3,4,5,6,7,8,9,10"|make_list %}
                                                    <option value="{{ i }}" {% if question.options_count == i|add:0 %}selected{% endif %}>{{ i }}</option>
                                                {% endfor %}
                                            </select>
                                            <span class="help-text">Available options: 
                                                <span class="mixed-available-options" data-question-num="{{ question.question_number }}" style="font-weight: 600; color: #2c3e50;">
                                                    {% with letters="ABCDEFGHIJ"|slice:question.options_count %}
                                                        {{ letters|join:", " }}
                                                    {% endwith %}
                                                </span>
                                            </span>
                                            <span class="help-text" style="margin-top: 5px;">This affects Multiple Choice components within this mixed question</span>
                                        </div>
                                    </div>
                                    <div class="info-note">
                                        <span class="control-icon">‚ÑπÔ∏è</span>
                                        <span>MIXED questions combine MCQ with text input fields</span>
                                    </div>
                                </div>
                                
                                <div id="mixed-container-{{ question.question_number }}">
                                    <div class="mixed-sections" id="mixed-sections-{{ question.question_number }}">
                                        <!-- Mixed sections will be populated via JS if data exists -->
                                    </div>
                                    <div style="display: flex; gap: 10px;">
                                        <button type="button" class="add-section-btn" onclick="addMixedSection({{ question.question_number }}, 'MCQ')">+ Add Multiple Choice</button>
                                        <button type="button" class="add-section-btn" onclick="addMixedSection({{ question.question_number }}, 'SHORT')">+ Add Short Answer</button>
                                        <button type="button" class="add-section-btn" onclick="addMixedSection({{ question.question_number }}, 'LONG')">+ Add Long Answer</button>
                                    </div>
                                </div>
                                <input type="hidden" 
                                       id="answer-{{ question.question_number }}" 
                                       data-question="{{ question.question_number }}"
                                       value="{{ question.correct_answer }}"
                                       class="answer-field">
                                <div class="answer-help">Create a mixed question with multiple answer types</div>
                            {% endif %}
                        </div>
                        <span class="save-indicator" id="saved-{{ question.question_number }}">‚úì Saved</span>
                    </div>
                </div>
                {% endfor %}
            </div>
            <div class="save-all-section">
                <span class="unsaved-indicator" id="unsaved-changes">
                    <i>‚ö† Unsaved changes</i>
                </span>
                <div class="action-buttons">
                    <button type="button" class="btn btn-secondary" onclick="clearAllAnswers()">
                        Clear All
                    </button>
                    <button type="button" class="btn btn-primary" onclick="saveAllAnswers()">
                        Save All Answers
                    </button>
                </div>
            </div>
        </div>
    </div>
    </div> <!-- End exam-wrapper -->
</div>

<!-- PDF.js for image conversion -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
// Wait for PDF.js to load properly
window.addEventListener('DOMContentLoaded', function() {
    // Set a timeout to ensure PDF.js is fully loaded
    setTimeout(function() {
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            console.log('PDF.js loaded successfully');
        } else {
            console.error('PDF.js library failed to load');
        }
    }, 100);
});
</script>
<script>
// Exam ID
const examId = "{{ exam.id }}";

// Answer tracking
let unsavedChanges = false;
const answers = {};

// Audio assignments tracking
let audioAssignments = {};

// Track changed audio names
const changedAudioNames = new Set();

// Track local audio display names
const localAudioNames = {};

// Answers are already loaded in the input fields from the backend

// Get CSRF token from cookie
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

console.log('üöÄ Script loading at ' + new Date().toISOString());

document.addEventListener('DOMContentLoaded', function() {
    console.log('üî• DOMContentLoaded fired! Timestamp: ' + new Date().toISOString());
    
    console.log('üîç DEBUG: audioAssignments initial state:', audioAssignments);
    
    // Initialize PDF image display
    initializePdfImageDisplay();
    
    // Initialize answer tracking
    initializeAnswerTracking();
    
    // Load saved local audio names
    loadLocalAudioNames();
    
    // Load audio assignments from Question.audio_file relationships
    console.log('üîç DEBUG: Template rendering questions...');
    {% for question in questions %}
        console.log('üîç Question {{ question.question_number }}: audio_file = {% if question.audio_file %}{{ question.audio_file.id }}{% else %}null{% endif %}');
    {% endfor %}
    
    const questionAudioData = [
        {% for question in questions %}
        {% if question.audio_file %}
        {
            questionNum: {{ question.question_number }},
            audioId: {{ question.audio_file.id }},
            audioName: "{{ question.audio_file.name|escapejs }}"
        },
        {% endif %}
        {% endfor %}
    ];
    
    console.log('üîç DEBUG: questionAudioData length:', questionAudioData.length);
    
    console.log('=== AUDIO ASSIGNMENT LOADING ===');
    console.log('questionAudioData:', questionAudioData);
    console.log('audioAssignments before loading:', audioAssignments);
    
    questionAudioData.forEach((data, index) => {
        console.log(`Loading assignment ${index + 1}: Q${data.questionNum} -> Audio ${data.audioId}`);
        
        // Load direct Question -> AudioFile relationships
        audioAssignments[data.questionNum] = data.audioId;
        console.log('‚úÖ Assignment: Q' + data.questionNum + ' -> Audio ID ' + data.audioId);
        
        const buttonSelector = `[data-question="${data.questionNum}"].audio-button`;
        console.log('üîç Looking for button with selector:', buttonSelector);
        
        const button = document.querySelector(buttonSelector);
        console.log('üîç Button found:', button ? 'YES' : 'NO');
        
        if (button) {
            button.classList.add('has-audio');
            // Use local name if available, otherwise use original
            const name = localAudioNames[data.audioId] || data.audioName;
            const displayName = name.substring(0, 20) + (name.length > 20 ? '...' : '');
            const newText = `üéµ Audio: ${displayName}`;
            button.innerHTML = newText;
            console.log(`‚úÖ Updated button for Q${data.questionNum}: "${newText}"`);
        } else {
            console.log(`‚ùå Button not found for Q${data.questionNum} with selector: ${buttonSelector}`);
        }
    });
    
    console.log('audioAssignments after loading:', audioAssignments);
    console.log('=== END AUDIO ASSIGNMENT LOADING ===');
    
    // Final check
    if (audioAssignments && typeof audioAssignments === 'object') {
        console.log('Final check - audioAssignments contains:', Object.keys(audioAssignments).length, 'assignments');
        for (const [q, audioId] of Object.entries(audioAssignments)) {
            console.log(`üí• FINAL: Q${q} -> Audio ${audioId}`);
        }
    } else {
        console.log('Final check - audioAssignments is not properly initialized');
    }
});

// PDF Image Display System
// PDF State Management - Properly declared variables
let pdfDoc = null;
let currentPage = 1;  // For simple PDF navigation
let currentPageNum = 1;  // For virtual page system (properly declared to fix scope issue)
let totalPages = 0;
let pageImages = new Map(); // Cache for converted images
let currentZoomLevel = 1.0; // Zoom level for image scaling
let currentRotation = {{ exam.pdf_rotation|default:0 }}; // Initialize rotation from saved value
let minZoom = 0.5;
let maxZoom = 3.0;

function initializePdfImageDisplay() {
    {% if exam.pdf_file %}
    const pdfUrl = "{{ exam.pdf_file.url }}";
    {% else %}
    const pdfUrl = null;
    {% endif %}
    
    if (!pdfUrl) {
        console.warn('No PDF file available for this exam');
        document.getElementById('pdf-loading').innerHTML = '<p class="text-muted">No PDF file uploaded for this exam</p>';
        return;
    }
    
    if (typeof pdfjsLib === 'undefined') {
        console.warn('PDF.js not loaded yet, retrying...');
        setTimeout(function() {
            initializePdfImageDisplay();
        }, 500);
        return;
    }
    
    pdfjsLib.getDocument(pdfUrl).promise.then(function(pdf) {
        pdfDoc = pdf;
        totalPages = pdf.numPages;
        currentPage = 1;
        pageImages.clear();
        
        // Update page info
        updatePageInfo();
        
        // Load first page
        renderPageAsImage(1);
        
        console.log('‚úÖ PDF loaded successfully:', totalPages, 'pages');
        
    }).catch(function(error) {
        console.error('Error loading PDF:', error);
        document.getElementById('pdf-loading').innerHTML = '<p style="color: red;">Error loading PDF. Please try again.</p>';
    });
}

function renderPageAsImage(pageNum) {
    if (!pdfDoc) {
        console.warn('[PREVIEW_EXAM] renderPageAsImage called but pdfDoc is null');
        return;
    }
    
    const loading = document.getElementById('pdf-loading');
    const pageImage = document.getElementById('pdf-page-image');
    
    if (!pageImage) {
        console.error('[PREVIEW_EXAM] PDF image display element not found');
        return;
    }
    
    // Clear cache when rotation changes (include rotation in cache key)
    const cacheKey = `${pageNum}_${currentRotation}`;
    
    // Check cache first
    if (pageImages.has(cacheKey)) {
        pageImage.src = pageImages.get(cacheKey);
        if (loading) loading.style.display = 'none';
        console.log('[PREVIEW_EXAM] Page loaded from cache:', { page: pageNum, rotation: currentRotation });
        return;
    }
    
    if (loading) loading.style.display = 'block';
    
    pdfDoc.getPage(pageNum).then(function(page) {
        // Create canvas for rendering with willReadFrequently for performance
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        if (!ctx) {
            console.error('[PREVIEW_EXAM] Failed to get canvas context');
            if (loading) loading.style.display = 'none';
            return;
        }
        
        // Calculate scale for good quality with rotation - increased for better readability
        const viewport = page.getViewport({ scale: 2.5, rotation: currentRotation });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        // Render page to canvas
        const renderContext = {
            canvasContext: ctx,
            viewport: viewport
        };
        
        page.render(renderContext).promise.then(function() {
            // Convert canvas to image
            const imageDataURL = canvas.toDataURL('image/png');
            
            // Cache the image with rotation key
            pageImages.set(cacheKey, imageDataURL);
            
            // Display the image
            if (pageImage) {
                pageImage.src = imageDataURL;
            }
            if (loading) {
                loading.style.display = 'none';
            }
            
            // Apply current zoom level to new image
            applyZoomToImage();
            updateZoomDisplay();
            
            console.log('[PREVIEW_EXAM] Page rendered as image:', { page: pageNum, rotation: currentRotation, cached: true });
        }).catch(function(error) {
            console.error('[PREVIEW_EXAM] Error rendering page:', error);
            if (loading) loading.style.display = 'none';
        });
    }).catch(function(error) {
        console.error('[PREVIEW_EXAM] Error getting PDF page:', error);
        if (loading) loading.style.display = 'none';
    });
}

function updatePageInfo() {
    // Update all navigation buttons (handle duplicate IDs)
    const prevButtons = document.querySelectorAll('[id="pdf-prev"]');
    const nextButtons = document.querySelectorAll('[id="pdf-next"]');
    const pageInput = document.getElementById('pdf-page-input');
    const totalPagesSpan = document.getElementById('total-pages');
    const jumpInput = document.getElementById('pdf-jump-input');
    const pageInfo = document.getElementById('pdf-page-info');
    
    // Update page counter display
    if (pageInfo) {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    }
    
    // Update previous buttons
    prevButtons.forEach(btn => {
        if (btn) {
            btn.disabled = currentPage === 1;
        }
    });
    
    // Update next buttons
    nextButtons.forEach(btn => {
        if (btn) {
            btn.disabled = currentPage === totalPages;
        }
    });
    if (pageInput) {
        pageInput.value = currentPage;
        pageInput.max = totalPages;
    }
    if (totalPagesSpan) {
        totalPagesSpan.textContent = totalPages;
    }
    if (jumpInput) {
        jumpInput.max = totalPages;
    }
}

function updateZoomDisplay() {
    const zoomElement = document.getElementById('pdf-zoom-level');
    if (zoomElement) {
        zoomElement.textContent = Math.round(currentZoomLevel * 100) + '%';
    }
}

function applyZoomToImage() {
    const pageImage = document.getElementById('pdf-page-image');
    if (!pageImage) {
        console.warn('[PREVIEW_EXAM] Cannot apply zoom - image element not found');
        return;
    }
    if (pageImage) {
        pageImage.style.transform = `scale(${currentZoomLevel})`;
        pageImage.style.transformOrigin = 'center center';
        console.log('‚úÖ Applied zoom level:', Math.round(currentZoomLevel * 100) + '%');
    }
}

function zoomIn() {
    if (currentZoomLevel < maxZoom) {
        currentZoomLevel = Math.min(currentZoomLevel * 1.2, maxZoom);
        applyZoomToImage();
        updateZoomDisplay();
    }
}

function zoomOut() {
    if (currentZoomLevel > minZoom) {
        currentZoomLevel = Math.max(currentZoomLevel / 1.2, minZoom);
        applyZoomToImage();
        updateZoomDisplay();
    }
}

function resetZoom() {
    currentZoomLevel = 1.0;
    applyZoomToImage();
    updateZoomDisplay();
}

// Navigation event listeners
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('pdf-prev')?.addEventListener('click', function() {
        if (currentPage > 1) {
            currentPage--;
            renderPageAsImage(currentPage);
            updatePageInfo();
        }
    });

    document.getElementById('pdf-next')?.addEventListener('click', function() {
        if (currentPage < totalPages) {
            currentPage++;
            renderPageAsImage(currentPage);
            updatePageInfo();
        }
    });

    // Zoom event listeners
    document.getElementById('pdf-zoom-in')?.addEventListener('click', function() {
        zoomIn();
    });

    document.getElementById('pdf-zoom-out')?.addEventListener('click', function() {
        zoomOut();
    });

    document.getElementById('pdf-zoom-level')?.addEventListener('dblclick', function() {
        resetZoom();
    });
});

// Removed complex PDF functions - replaced with image display system

// Helper function to mark as unsaved
// [REMOVED] initializePdfViewer_REMOVED function deleted
// This was causing duplicate initialization and scope issues
// The active PDF system uses initializePdfImageDisplay() above

// Detect content boundaries to minimize white space and improve resolution
function detectContentBoundaries(canvas, ctx) {
    console.log('üîç [PREVIEW_EXAM] Starting content boundary detection...');
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    
    // Detect top boundary (first row with content)
    let topBoundary = 0;
    for (let y = 0; y < height; y++) {
        let hasContent = false;
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            // Check if pixel is not white/near-white (allowing for scanning artifacts)
            if (r < 240 || g < 240 || b < 240) {
                hasContent = true;
                break;
            }
        }
        if (hasContent) {
            topBoundary = Math.max(0, y - 10); // Add small margin
            break;
        }
    }
    
    // Detect bottom boundary (last row with content)
    let bottomBoundary = height;
    for (let y = height - 1; y >= 0; y--) {
        let hasContent = false;
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            if (r < 240 || g < 240 || b < 240) {
                hasContent = true;
                break;
            }
        }
        if (hasContent) {
            bottomBoundary = Math.min(height, y + 10); // Add small margin
            break;
        }
    }
    
    console.log('üîç [PREVIEW_EXAM] Content boundaries detected:', {
        topBoundary,
        bottomBoundary,
        contentHeight: bottomBoundary - topBoundary,
        originalHeight: height,
        whitespaceReduction: Math.round((1 - (bottomBoundary - topBoundary) / height) * 100) + '%'
    });
    
    return { topBoundary, bottomBoundary };
}

// Detect divider line in scanned PDF page (enhanced with content boundaries)
function detectDividerLine(canvas, ctx, viewport) {
    console.log('üîç [PREVIEW_EXAM] Starting divider line detection...');
    
    // Get image data from the full page canvas
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    
    console.log('üîç [PREVIEW_EXAM] Canvas dimensions:', { width, height });
    
    // Search range: 40%-60% of page width (as specified)
    const searchStartX = Math.floor(width * 0.4);
    const searchEndX = Math.floor(width * 0.6);
    const searchWidth = searchEndX - searchStartX;
    
    console.log('üîç [PREVIEW_EXAM] Search range:', { 
        searchStartX, 
        searchEndX, 
        searchWidth,
        percentageRange: '40%-60%'
    });
    
    // Enhanced divider detection using content gap analysis
    const sampleInterval = Math.max(1, Math.floor(searchWidth / 100)); // Increased sampling density
    let bestDividerX = Math.floor(width / 2); // Default to 50% if no line found
    let maxScore = 0;
    
    console.log('üîç [PREVIEW_EXAM] Enhanced sample interval:', sampleInterval);
    
    // Method 1: Content gap detection - look for vertical strips with minimal content
    const contentAnalysis = [];
    for (let x = searchStartX; x < searchEndX; x += sampleInterval) {
        let contentPixels = 0;
        let totalPixels = 0;
        let subtleFeatures = 0;
        
        // Sample pixels vertically through the strip (focus on content area)
        const sampleStartY = Math.floor(height * 0.15);
        const sampleEndY = Math.floor(height * 0.85);
        const verticalSampleInterval = Math.max(1, Math.floor((sampleEndY - sampleStartY) / 40));
        
        for (let y = sampleStartY; y < sampleEndY; y += verticalSampleInterval) {
            const pixelIndex = (y * width + x) * 4;
            const r = data[pixelIndex];
            const g = data[pixelIndex + 1];
            const b = data[pixelIndex + 2];
            const brightness = (r + g + b) / 3;
            
            totalPixels++;
            
            // Detect content pixels (not pure white)
            if (brightness < 240) {
                contentPixels++;
            }
            
            // Detect subtle features (slightly off-white, like book spine shadows)
            if (brightness >= 240 && brightness < 250) {
                subtleFeatures++;
            }
        }
        
        const contentRatio = totalPixels > 0 ? contentPixels / totalPixels : 0;
        const subtleRatio = totalPixels > 0 ? subtleFeatures / totalPixels : 0;
        
        contentAnalysis.push({ x, contentRatio, subtleRatio });
    }
    
    // Method 2: Multi-factor scoring for book spine detection
    for (let i = 0; i < contentAnalysis.length; i++) {
        const current = contentAnalysis[i];
        let score = 0;
        
        // Factor 1: Low content density (spine areas have less text/content)
        const contentGapScore = (1 - current.contentRatio) * 40;
        score += contentGapScore;
        
        // Factor 2: Proximity to center (book spines are typically near 50%)
        const distanceFromCenter = Math.abs((current.x / width) - 0.5);
        const centerScore = (1 - distanceFromCenter * 2) * 30;
        score += centerScore;
        
        // Factor 3: Subtle features (spine shadows, binding lines)
        const subtleScore = current.subtleRatio * 25;
        score += subtleScore;
        
        // Factor 4: Content transition detection (left content vs right content)
        if (i >= 2 && i < contentAnalysis.length - 2) {
            const leftContent = (contentAnalysis[i-2].contentRatio + contentAnalysis[i-1].contentRatio) / 2;
            const rightContent = (contentAnalysis[i+1].contentRatio + contentAnalysis[i+2].contentRatio) / 2;
            const transitionScore = Math.abs(leftContent - rightContent) * 20;
            score += transitionScore;
        }
        
        // Factor 5: Vertical consistency (spine features should be consistent vertically)
        let verticalConsistency = 0;
        const checkPoints = 8;
        const sampleStartY = Math.floor(height * 0.2);
        const sampleEndY = Math.floor(height * 0.8);
        
        for (let j = 0; j < checkPoints; j++) {
            const y = sampleStartY + Math.floor(j * (sampleEndY - sampleStartY) / checkPoints);
            const pixelIndex = (y * width + current.x) * 4;
            const r = data[pixelIndex];
            const g = data[pixelIndex + 1];
            const b = data[pixelIndex + 2];
            const brightness = (r + g + b) / 3;
            
            // Look for consistent non-content pixels (white-ish or subtle shadows)
            if (brightness >= 235) {
                verticalConsistency++;
            }
        }
        
        const consistencyScore = (verticalConsistency / checkPoints) * 15;
        score += consistencyScore;
        
        if (score > maxScore) {
            maxScore = score;
            bestDividerX = current.x;
            
            console.log('üîç [PREVIEW_EXAM] New best divider candidate:', {
                x: current.x,
                ratio: (current.x / width).toFixed(3),
                contentRatio: current.contentRatio.toFixed(3),
                subtleRatio: current.subtleRatio.toFixed(3),
                score: score.toFixed(2),
                factors: {
                    contentGap: contentGapScore.toFixed(1),
                    center: centerScore.toFixed(1),
                    subtle: subtleScore.toFixed(1),
                    consistency: consistencyScore.toFixed(1)
                }
            });
        }
    }
    
    // Validate the detected position
    const dividerRatio = bestDividerX / width;
    let finalDividerX;
    
    if (dividerRatio >= 0.4 && dividerRatio <= 0.6) {
        finalDividerX = bestDividerX;
        console.log('‚úÖ [PREVIEW_EXAM] Enhanced divider detected at:', {
            x: finalDividerX,
            ratio: dividerRatio,
            percentage: Math.round(dividerRatio * 100) + '%',
            score: maxScore.toFixed(2),
            method: 'Content gap analysis with multi-factor scoring'
        });
    } else {
        finalDividerX = Math.floor(width / 2); // Fallback to 50%
        console.log('‚ö†Ô∏è [PREVIEW_EXAM] Enhanced detection out of range, using 50% fallback:', {
            detectedX: bestDividerX,
            detectedRatio: dividerRatio,
            detectedScore: maxScore.toFixed(2),
            fallbackX: finalDividerX,
            fallbackRatio: 0.5
        });
    }
    
    return finalDividerX;
}

// Legacy renderPage function - now safely redirects to image rendering
function renderPage(vPageNum) {
    console.log('[PREVIEW_EXAM] Legacy renderPage called, redirecting to renderPageAsImage:', vPageNum);
    
    if (!pdfDoc) {
        console.error('[PREVIEW_EXAM] No pdfDoc available for rendering');
        return;
    }
    
    // Ensure page number is valid
    const pageNum = Math.min(Math.max(1, vPageNum), totalPages);
    
    // Update current page and render as image
    currentPage = pageNum;
    currentPageNum = pageNum; // Keep legacy variable in sync
    renderPageAsImage(pageNum);
    updatePageInfo();
    updateNavigationButtons();
    return;
    
    // The rest of this function is no longer used
    return;
    
    console.log('üî• [PREVIEW_EXAM] Virtual to actual page mapping:', {
        virtualPage: vPageNum,
        actualPage: actualPageNum,
        isLeftColumn,
        columnText: isLeftColumn ? 'Left' : 'Right'
    });
    
    console.log('üî• [PREVIEW_EXAM] Getting actual page', actualPageNum, 'from PDF...');
    pdfDoc.getPage(actualPageNum).then(function(page) {
        console.log('‚úÖ [PREVIEW_EXAM] Successfully got actual page', actualPageNum);
        
        currentPdfPage = page; // Store for zoom operations
        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        
        console.log('üî• [PREVIEW_EXAM] Canvas element found:', !!canvas);
        console.log('üî• [PREVIEW_EXAM] Canvas context obtained:', !!ctx);
        
        // Get container dimensions
        const container = document.getElementById('pdf-viewer');
        const containerWidth = container.clientWidth - 20;
        const containerHeight = container.clientHeight - 20;
        
        console.log('üî• [PREVIEW_EXAM] Container dimensions:', {
            containerWidth,
            containerHeight,
            containerClientWidth: container.clientWidth,
            containerClientHeight: container.clientHeight
        });
        
        // Get page viewport at scale 1
        const viewport = page.getViewport({ scale: 1 });
        
        console.log('üî• [PREVIEW_EXAM] Page viewport at scale 1:', {
            width: viewport.width,
            height: viewport.height
        });
        
        // Enhanced scale calculation for maximum content utilization
        const targetWidth = containerWidth * 0.95; // Use 95% of container width
        const targetHeight = containerHeight * 0.90; // Use 90% of container height
        
        // Scale for half-width display but optimize for content visibility
        const scaleX = (targetWidth * 1.8) / viewport.width; // Increased multiplier for better width usage
        const scaleY = targetHeight / viewport.height;
        
        // Use higher minimum scale for better readability, prioritize content size
        const scale = Math.max(Math.min(scaleX, scaleY), 1.8); // Optimized minimum scale for readability
        
        console.log('üî• [PREVIEW_EXAM] Scale calculations for column view:', {
            originalViewportWidth: viewport.width,
            halfPageWidth: viewport.width / 2,
            scaleX,
            scaleY,
            finalScale: scale,
            scalingPercentage: Math.round(scale * 100)
        });
        
        // Get scaled viewport for rendering
        const scaledViewport = page.getViewport({ scale: scale });
        
        console.log('üî• [PREVIEW_EXAM] Scaled viewport:', {
            width: scaledViewport.width,
            height: scaledViewport.height
        });
        
        // Set canvas size for column view (true half of original page width - match Student interface)
        // Height set initially, width will be set after divider detection
        canvas.height = scaledViewport.height;
        
        console.log('üî• [PREVIEW_EXAM] Initial canvas setup for adaptive column view:', {
            height: canvas.height,
            originalPageWidth: scaledViewport.width,
            note: 'Canvas width will be set after divider detection'
        });
        
        // Create a temporary canvas for full page rendering
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = scaledViewport.width;
        tempCanvas.height = scaledViewport.height;
        
        console.log('üî• [PREVIEW_EXAM] Temporary canvas created for full page:', {
            width: tempCanvas.width,
            height: tempCanvas.height
        });
        
        // Render full page to temp canvas
        const renderContext = {
            canvasContext: tempCtx,
            viewport: scaledViewport
        };
        
        console.log('üî• [PREVIEW_EXAM] Starting full page render to temp canvas...');
        
        const renderPromise = page.render(renderContext);
        
        renderPromise.promise.then(() => {
            console.log('‚úÖ [PREVIEW_EXAM] Full page rendered to temp canvas successfully');
            
            // Detect content boundaries to minimize white space
            const contentBounds = detectContentBoundaries(tempCanvas, tempCtx);
            
            // Detect or retrieve cached divider position for this page
            let dividerX;
            const pageKey = `page_${actualPageNum}`;
            
            if (detectedDividers.has(pageKey)) {
                dividerX = detectedDividers.get(pageKey);
                console.log('üìã [PREVIEW_EXAM] Using cached divider position:', { pageKey, dividerX });
            } else {
                // Detect divider line in the full page
                dividerX = detectDividerLine(tempCanvas, tempCtx, viewport);
                detectedDividers.set(pageKey, dividerX);
                console.log('üîç [PREVIEW_EXAM] Detected and cached divider position:', { pageKey, dividerX });
            }
            
            // Calculate source region with content boundaries for optimal display
            let sourceX, sourceWidth, sourceY, sourceHeight;
            if (isLeftColumn) {
                sourceX = 0;
                sourceWidth = dividerX;
            } else {
                sourceX = dividerX;
                sourceWidth = scaledViewport.width - dividerX; // Remaining width after divider
            }
            
            // Use content boundaries to eliminate white space
            sourceY = contentBounds.topBoundary;
            sourceHeight = contentBounds.bottomBoundary - contentBounds.topBoundary;
            
            // Calculate optimized canvas dimensions
            const canvasWidth = sourceWidth * scale;
            const canvasHeight = sourceHeight * scale;
            
            // Set canvas size to content-optimized dimensions
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            console.log('üî• [PREVIEW_EXAM] Content-optimized canvas dimensions:', {
                canvasWidth,
                canvasHeight,
                sourceWidth,
                sourceHeight,
                contentHeightReduction: Math.round((1 - sourceHeight / scaledViewport.height) * 100) + '%'
            });
            
            // Clear main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            console.log('üî• [PREVIEW_EXAM] Copying optimized content area from temp canvas:', {
                isLeftColumn,
                dividerX,
                dividerRatio: (dividerX / scaledViewport.width).toFixed(3),
                sourceX,
                sourceY,
                sourceWidth,
                sourceHeight,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                scale: scale,
                qualityImprovement: 'Content-focused rendering with boundary detection'
            });
            
            ctx.drawImage(
                tempCanvas,
                sourceX, sourceY, sourceWidth, sourceHeight,  // source (content-optimized area)
                0, 0, canvas.width, canvas.height            // destination (full canvas)
            );
            
            console.log('‚úÖ [PREVIEW_EXAM] Adaptive column copied to main canvas successfully');
            
            // Update zoom level display
            const zoomElement = document.getElementById('pdf-zoom-level');
            if (zoomElement) {
                zoomElement.textContent = Math.round(currentZoomLevel * 100) + '%';
                console.log('üî• [PREVIEW_EXAM] Base zoom level set to:', Math.round(currentZoomLevel * 100) + '%');
            } else {
                console.warn('‚ö†Ô∏è [PREVIEW_EXAM] Zoom level element not found');
            }
            
        }).catch((error) => {
            console.error('‚ùå [PREVIEW_EXAM] Error rendering page:', error);
        });
        
    }).catch(function(error) {
        console.error('‚ùå [PREVIEW_EXAM] Error getting page', actualPageNum, ':', error);
    });
    
    // Update page counter
    const pageCountElement = document.getElementById('current-page');
    if (pageCountElement) {
        const columnText = (vPageNum % 2) === 1 ? '(Left)' : '(Right)';
        pageCountElement.textContent = `${vPageNum} ${columnText}`;
        console.log('üî• [PREVIEW_EXAM] Page counter updated to:', `${vPageNum} ${columnText}`);
    } else {
        console.warn('‚ö†Ô∏è [PREVIEW_EXAM] Page counter element not found');
    }
}

function updateNavigationButtons() {
    const skipFirstLeftHalf = false;
    const minPage = skipFirstLeftHalf ? 2 : 1;
    document.getElementById('pdf-prev').disabled = currentPageNum <= minPage;
    document.getElementById('pdf-next').disabled = currentPageNum >= totalPages;
}

// PDF navigation - Fixed to use image rendering and handle duplicate IDs
// Handle all navigation buttons (both control bar and overlay have same IDs)
const prevButtons = document.querySelectorAll('[id="pdf-prev"]');
const nextButtons = document.querySelectorAll('[id="pdf-next"]');

console.log('[PREVIEW_EXAM] Found navigation buttons:', { prevCount: prevButtons.length, nextCount: nextButtons.length });

prevButtons.forEach((button, index) => {
    button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!pdfDoc || currentPage <= 1) {
            console.log('[PREVIEW_EXAM] Cannot go to previous page:', { currentPage, totalPages });
            return;
        }
        currentPage--;
        console.log('[PREVIEW_EXAM] Previous button clicked:', { buttonIndex: index, newPage: currentPage, totalPages });
        renderPageAsImage(currentPage);
        updatePageInfo();
    });
});

nextButtons.forEach((button, index) => {
    button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!pdfDoc || currentPage >= totalPages) {
            console.log('[PREVIEW_EXAM] Cannot go to next page:', { currentPage, totalPages });
            return;
        }
        currentPage++;
        console.log('[PREVIEW_EXAM] Next button clicked:', { buttonIndex: index, newPage: currentPage, totalPages });
        renderPageAsImage(currentPage);
        updatePageInfo();
    });
});

// Rotate left button
document.getElementById('pdf-rotate-left').addEventListener('click', function() {
    if (!pdfDoc) return;
    
    currentRotation = (currentRotation - 90) % 360;
    if (currentRotation < 0) currentRotation += 360;
    
    console.log('üî• [PREVIEW_EXAM] Rotate left clicked, new rotation:', currentRotation);
    renderPageAsImage(currentPage); // Re-render current page with new rotation
});

// Rotate right button
document.getElementById('pdf-rotate-right').addEventListener('click', function() {
    if (!pdfDoc) return;
    
    currentRotation = (currentRotation + 90) % 360;
    
    console.log('üî• [PREVIEW_EXAM] Rotate right clicked, new rotation:', currentRotation);
    renderPageAsImage(currentPage); // Re-render current page with new rotation
});

// Page input navigation
document.getElementById('pdf-page-input')?.addEventListener('change', function() {
    const targetPage = parseInt(this.value);
    if (targetPage >= 1 && targetPage <= totalPages && targetPage !== currentPage) {
        currentPage = targetPage;
        console.log('üî• [PREVIEW_EXAM] Page input changed to:', currentPage);
        renderPageAsImage(currentPage);
        updatePageInfo();
    } else {
        // Reset to current page if invalid
        this.value = currentPage;
    }
});

// Jump to page functionality
document.getElementById('pdf-jump-btn')?.addEventListener('click', function() {
    const jumpInput = document.getElementById('pdf-jump-input');
    if (jumpInput) {
        const targetPage = parseInt(jumpInput.value);
        if (targetPage >= 1 && targetPage <= totalPages) {
            currentPage = targetPage;
            console.log('üî• [PREVIEW_EXAM] Jump to page:', currentPage);
            renderPageAsImage(currentPage);
            updatePageInfo();
            jumpInput.value = ''; // Clear after jump
        } else {
            alert(`Please enter a page number between 1 and ${totalPages}`);
        }
    }
});

// Jump input enter key support
document.getElementById('pdf-jump-input')?.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        document.getElementById('pdf-jump-btn')?.click();
    }
});

// Old complex zoom functions removed - replaced with simple image scaling system

function reRenderAtZoomLevel_REMOVED() {
    if (!currentPdfPage) return;
    
    console.log('üîç [PREVIEW_EXAM] Re-rendering at zoom level:', currentZoomLevel);
    
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('pdf-viewer');
    
    // Calculate enhanced scale combining base scale and zoom
    const combinedScale = baseRenderScale * currentZoomLevel;
    
    // Get fresh viewport with combined scale
    const zoomedViewport = currentPdfPage.getViewport({ scale: combinedScale });
    
    // Create temporary canvas for full page at zoomed scale
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = zoomedViewport.width;
    tempCanvas.height = zoomedViewport.height;
    
    // Render at high resolution
    const renderContext = {
        canvasContext: tempCtx,
        viewport: zoomedViewport
    };
    
    currentPdfPage.render(renderContext).promise.then(() => {
        // Detect content boundaries at this scale
        const contentBounds = detectContentBoundaries(tempCanvas, tempCtx);
        
        // Get cached divider position and scale it
        const pageKey = `page_${Math.ceil(currentPageNum / 2)}`;
        let dividerX = detectedDividers.get(pageKey) || (zoomedViewport.width / 2);
        dividerX = dividerX * (combinedScale / baseRenderScale); // Scale divider to current zoom
        
        // Determine column extraction
        const isLeftColumn = (currentPageNum % 2 === 1);
        let sourceX, sourceWidth;
        
        if (isLeftColumn) {
            sourceX = 0;
            sourceWidth = dividerX;
        } else {
            sourceX = dividerX;
            sourceWidth = zoomedViewport.width - dividerX;
        }
        
        // Use content boundaries
        const sourceY = contentBounds.topBoundary;
        const sourceHeight = contentBounds.bottomBoundary - contentBounds.topBoundary;
        
        // Set final canvas size
        canvas.width = sourceWidth;
        canvas.height = sourceHeight;
        
        // Copy optimized content
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(
            tempCanvas,
            sourceX, sourceY, sourceWidth, sourceHeight,
            0, 0, canvas.width, canvas.height
        );
        
        // Update zoom display
        const zoomElement = document.getElementById('pdf-zoom-level');
        if (zoomElement) {
            zoomElement.textContent = Math.round(currentZoomLevel * 100) + '%';
        }
        
        // Reset any CSS transforms that might interfere
        container.style.transform = 'none';
        
        console.log('‚úÖ [PREVIEW_EXAM] High-quality zoom render complete:', {
            zoomLevel: currentZoomLevel,
            combinedScale,
            finalCanvasSize: { width: canvas.width, height: canvas.height }
        });
    });
}

// Note: Skip First Left Half control removed - setting is now configured during exam upload
// Display behavior - skip_first_left_half is disabled (field removed)

// Answer tracking functions
function initializeAnswerTracking() {
    // Initialize questions from saved data
    document.querySelectorAll('.question-entry').forEach(entry => {
        const questionNum = entry.dataset.questionNumber;
        const typeSelect = entry.querySelector('.question-type-select');
        const answerField = entry.querySelector('.answer-field');
        
        // Initialize SHORT answers with multiple responses
        if (typeSelect.value === 'SHORT' && answerField.value && answerField.value.includes('|')) {
            const responses = answerField.value.split('|').filter(r => r.trim());
            if (responses.length > 1) {
                const container = document.getElementById(`responses-${questionNum}`);
                if (container) {
                    container.innerHTML = '';
                    responses.forEach((response, index) => {
                        const responseDiv = document.createElement('div');
                        responseDiv.className = 'response-item';
                        responseDiv.innerHTML = `
                            <input type="text" 
                                   value="${response}"
                                   placeholder="Acceptable response ${index + 1}"
                                   onchange="updateShortAnswers(${questionNum})">
                            ${index > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                        `;
                        container.appendChild(responseDiv);
                    });
                }
            }
        }
        
        // Initialize LONG answers with multiple responses
        if (typeSelect.value === 'LONG' && answerField.value && answerField.value.includes('|||')) {
            const responses = answerField.value.split('|||').filter(r => r.trim());
            if (responses.length > 1) {
                const container = document.getElementById(`responses-${questionNum}`);
                if (container) {
                    container.innerHTML = '';
                    responses.forEach((response, index) => {
                        const responseDiv = document.createElement('div');
                        responseDiv.className = 'response-item';
                        responseDiv.innerHTML = `
                            <textarea placeholder="Grading guideline or sample answer ${index + 1}"
                                      onchange="updateLongAnswers(${questionNum})"
                                      style="min-height: 80px; width: 100%;">${response}</textarea>
                            ${index > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                        `;
                        container.appendChild(responseDiv);
                    });
                }
            }
        }
        
        // Initialize MIXED questions
        if (typeSelect.value === 'MIXED' && answerField.value) {
            try {
                const mixedData = JSON.parse(answerField.value);
                initializeMixedQuestion(questionNum, mixedData);
            } catch (e) {
                console.error('Error parsing mixed data for question', questionNum, e);
            }
        }
    });
    
    // Handle answer field changes
    document.querySelectorAll('.answer-field').forEach(input => {
        input.addEventListener('input', function() {
            const questionNum = this.dataset.question;
            answers[questionNum] = this.value;
            unsavedChanges = true;
            document.getElementById('unsaved-changes').style.display = 'inline';
            document.getElementById(`saved-${questionNum}`).style.display = 'none';
        });
        
        // Auto-save on blur
        input.addEventListener('blur', function() {
            if (this.value && unsavedChanges) {
                saveAnswer(this.dataset.question, this.value);
            }
        });
    });
    
    // Handle question type changes
    document.querySelectorAll('.question-type-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionNum = this.dataset.question;
            const newType = this.value;
            updateAnswerInput(questionNum, newType);
            
            // Show/hide MCQ options
            const mcqOptions = document.getElementById(`mcq-options-${questionNum}`);
            if (newType === 'MCQ') {
                mcqOptions.style.display = 'inline';
            } else {
                mcqOptions.style.display = 'none';
            }
            
            unsavedChanges = true;
            document.getElementById('unsaved-changes').style.display = 'inline';
            document.getElementById(`saved-${questionNum}`).style.display = 'none';
        });
    });
    
    // Handle MIXED question options count changes
    document.querySelectorAll('.mixed-options-count-selector').forEach(selector => {
        selector.addEventListener('change', function() {
            const questionNum = this.dataset.questionNum;
            const questionId = this.dataset.questionId;
            const newCount = parseInt(this.value);
            
            // Update the display of available options
            const availableOptionsDiv = document.querySelector(`.mixed-available-options[data-question-num="${questionNum}"]`);
            if (availableOptionsDiv) {
                const letters = 'ABCDEFGHIJ'.slice(0, newCount);
                availableOptionsDiv.textContent = letters.split('').join(', ');
            }
            
            // Update any existing MCQ components to use the new options count
            const existingMcqSections = document.querySelectorAll(`#mixed-sections-${questionNum} .mixed-answer-section`);
            existingMcqSections.forEach(section => {
                const typeLabel = section.querySelector('.mixed-type-label');
                if (typeLabel && typeLabel.textContent === 'Multiple Choice') {
                    // Recreate the MCQ options with new count
                    const mcqOptionsDiv = section.querySelector('.mcq-options');
                    if (mcqOptionsDiv) {
                        const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, newCount);
                        const sectionId = section.id;
                        
                        // Preserve selected values if they're still valid
                        const selectedButtons = section.querySelectorAll('.mcq-button.selected');
                        const selectedValues = Array.from(selectedButtons).map(btn => btn.dataset.value).filter(val => letters.includes(val));
                        
                        // Recreate buttons
                        mcqOptionsDiv.innerHTML = letters.map(letter => `
                            <button type="button" 
                                    class="mcq-button ${selectedValues.includes(letter) ? 'selected' : ''}"
                                    data-section="${sectionId}"
                                    data-value="${letter}"
                                    onclick="selectMixedMCQ('${sectionId}', '${letter}', ${questionNum})">
                                ${letter}
                            </button>
                        `).join('');
                    }
                }
            });
            
            // Save the options count to the question
            if (questionId) {
                const formData = new FormData();
                formData.append('options_count', newCount);
                const csrf = getCSRFToken();
                if (csrf) {
                    formData.append('csrfmiddlewaretoken', csrf);
                } else {
                    console.warn('[OPTIONS] No CSRF token available');
                }
                
                fetch(`/api/PlacementTest/questions/${questionId}/update/`, {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`Updated MIXED question ${questionNum} options count to ${newCount}`);
                    } else {
                        console.error('Failed to update options count:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error updating options count:', error);
                });
            }
            
            unsavedChanges = true;
            document.getElementById('unsaved-changes').style.display = 'inline';
            document.getElementById(`saved-${questionNum}`).style.display = 'none';
        });
    });
}

// Update answer input based on question type
function updateAnswerInput(questionNum, questionType) {
    const container = document.getElementById(`answer-container-${questionNum}`);
    const currentValue = document.getElementById(`answer-${questionNum}`) ? 
                        document.getElementById(`answer-${questionNum}`).value : '';
    
    let newHtml = '';
    
    switch(questionType) {
        case 'MCQ':
            const selectedLetters = currentValue.split(',').map(v => v.trim().toUpperCase());
            const optionsCount = parseInt(document.getElementById(`options-count-${questionNum}`)?.value || 5);
            const isMultiple = document.getElementById(`multi-${questionNum}`)?.checked || false;
            const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, optionsCount);
            
            newHtml = `
                <div class="mcq-options">
                    ${letters.map(letter => `
                        <button type="button" 
                                class="mcq-button ${selectedLetters.includes(letter) ? 'selected' : ''}"
                                data-question="${questionNum}"
                                data-value="${letter}"
                                data-multiple="${isMultiple}"
                                onclick="selectMCQ(${questionNum}, '${letter}')">
                            ${letter}
                        </button>
                    `).join('')}
                </div>
                <input type="hidden" 
                       id="answer-${questionNum}" 
                       data-question="${questionNum}"
                       value="${currentValue}"
                       class="answer-field">
                <div class="answer-help" id="mcq-help-${questionNum}">
                    ${isMultiple ? 'Click to select correct answer(s) - multiple selections allowed' : 'Click to select the correct answer'}
                </div>
            `;
            break;
            
        case 'CHECKBOX':
            const selectedValues = currentValue.split(',').map(v => v.trim().toUpperCase());
            newHtml = `
                <div class="checkbox-options">
                    ${['A', 'B', 'C', 'D', 'E'].map(letter => `
                        <div class="checkbox-option">
                            <input type="checkbox" 
                                   id="check-${questionNum}-${letter}"
                                   value="${letter}"
                                   ${selectedValues.includes(letter) ? 'checked' : ''}
                                   onchange="updateCheckboxes(${questionNum})">
                            <label for="check-${questionNum}-${letter}">${letter}</label>
                        </div>
                    `).join('')}
                </div>
                <input type="hidden" 
                       id="answer-${questionNum}" 
                       data-question="${questionNum}"
                       value="${currentValue}"
                       class="answer-field">
                <div class="answer-help">Select all correct answers</div>
            `;
            break;
            
        case 'SHORT':
            const responses = currentValue ? currentValue.split('|').filter(r => r.trim()) : [''];
            newHtml = `
                <div class="short-answer-responses" id="responses-${questionNum}">
                    ${responses.map((response, index) => `
                        <div class="response-item">
                            <input type="text" 
                                   value="${response}"
                                   placeholder="Acceptable response ${index + 1}"
                                   onchange="updateShortAnswers(${questionNum})">
                            ${index > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                        </div>
                    `).join('')}
                </div>
                <button type="button" class="add-response" onclick="addResponse(${questionNum})">+ Add Response</button>
                <input type="hidden" 
                       id="answer-${questionNum}" 
                       data-question="${questionNum}"
                       value="${currentValue}"
                       class="answer-field">
                <div class="answer-help">Add multiple acceptable responses</div>
            `;
            break;
            
        case 'LONG':
            const longResponses = currentValue ? currentValue.split('|||').filter(r => r.trim()) : [''];
            newHtml = `
                <div class="short-answer-responses" id="responses-${questionNum}">
                    ${longResponses.map((response, index) => `
                        <div class="response-item">
                            <textarea placeholder="Grading guideline or sample answer ${index + 1}"
                                      onchange="updateLongAnswers(${questionNum})"
                                      style="min-height: 80px; width: 100%;">${response}</textarea>
                            ${index > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                        </div>
                    `).join('')}
                </div>
                <button type="button" class="add-response" onclick="addLongResponse(${questionNum})">+ Add Grading Guideline</button>
                <input type="hidden" 
                       id="answer-${questionNum}" 
                       data-question="${questionNum}"
                       value="${currentValue}"
                       class="answer-field">
                <div class="answer-help">Add multiple grading guidelines or sample answers</div>
            `;
            break;
            
        case 'MIXED':
            // Get existing options count from the DOM if available
            const existingSelector = document.getElementById(`mixed-options-count-${questionNum}`);
            const currentOptionsCount = existingSelector ? existingSelector.value : 5;
            
            newHtml = `
                <!-- MCQ Options Count Selector for MIXED questions - Improved UI -->
                <div class="mixed-options-container">
                    <div class="mcq-control-group mixed-choices-group">
                        <div class="control-header">
                            <span class="control-icon">üî¢</span>
                            <label for="mixed-options-count-${questionNum}">MCQ Component Settings</label>
                        </div>
                        <div class="control-body">
                            <label class="sub-label">Number of MCQ Options:</label>
                            <select class="form-control mixed-options-count-selector" name="mixed_options_count" 
                                    data-question-num="${questionNum}"
                                    id="mixed-options-count-${questionNum}"
                                    style="width: 100px;">
                                ${[2,3,4,5,6,7,8,9,10].map(i => `
                                    <option value="${i}" ${currentOptionsCount == i ? 'selected' : ''}>${i}</option>
                                `).join('')}
                            </select>
                            <span class="help-text">Available options: 
                                <span class="mixed-available-options" data-question-num="${questionNum}" style="font-weight: 600; color: #2c3e50;">
                                    ${'ABCDEFGHIJ'.slice(0, currentOptionsCount).split('').join(', ')}
                                </span>
                            </span>
                            <span class="help-text" style="margin-top: 5px;">This affects Multiple Choice components within this mixed question</span>
                        </div>
                    </div>
                    <div class="info-note">
                        <span class="control-icon">‚ÑπÔ∏è</span>
                        <span>MIXED questions combine MCQ with text input fields</span>
                    </div>
                </div>
                
                <div id="mixed-container-${questionNum}">
                    <div class="mixed-sections" id="mixed-sections-${questionNum}">
                        <!-- Mixed sections will be added here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button type="button" class="add-section-btn" onclick="addMixedSection(${questionNum}, 'MCQ')">+ Add Multiple Choice</button>
                        <button type="button" class="add-section-btn" onclick="addMixedSection(${questionNum}, 'SHORT')">+ Add Short Answer</button>
                        <button type="button" class="add-section-btn" onclick="addMixedSection(${questionNum}, 'LONG')">+ Add Long Answer</button>
                    </div>
                </div>
                <input type="hidden" 
                       id="answer-${questionNum}" 
                       data-question="${questionNum}"
                       value="${currentValue}"
                       class="answer-field">
                <div class="answer-help">Create a mixed question with multiple answer types</div>
            `;
            break;
    }
    
    container.innerHTML = newHtml;
    
    // Re-attach event listeners based on type
    if (questionType === 'LONG') {
        // Long answers use hidden input, update immediately
        updateLongAnswers(questionNum);
    } else if (questionType === 'SHORT') {
        updateShortAnswers(questionNum);
    } else if (questionType === 'MIXED') {
        // Initialize mixed with empty data
        updateMixedAnswers(questionNum);
        
        // Re-attach event handlers for MIXED options count selector
        const selector = document.getElementById(`mixed-options-count-${questionNum}`);
        if (selector) {
            selector.addEventListener('change', function() {
                const questionNum = this.dataset.questionNum;
                const newCount = parseInt(this.value);
                
                // Update the display of available options
                const availableOptionsDiv = document.querySelector(`.mixed-available-options[data-question-num="${questionNum}"]`);
                if (availableOptionsDiv) {
                    const letters = 'ABCDEFGHIJ'.slice(0, newCount);
                    availableOptionsDiv.textContent = letters.split('').join(', ');
                }
                
                // Update any existing MCQ components to use the new options count
                const existingMcqSections = document.querySelectorAll(`#mixed-sections-${questionNum} .mixed-answer-section`);
                existingMcqSections.forEach(section => {
                    const typeLabel = section.querySelector('.mixed-type-label');
                    if (typeLabel && typeLabel.textContent === 'Multiple Choice') {
                        // Recreate the MCQ options with new count
                        const mcqOptionsDiv = section.querySelector('.mcq-options');
                        if (mcqOptionsDiv) {
                            const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, newCount);
                            const sectionId = section.id;
                            
                            // Preserve selected values if they're still valid
                            const selectedButtons = section.querySelectorAll('.mcq-button.selected');
                            const selectedValues = Array.from(selectedButtons).map(btn => btn.dataset.value).filter(val => letters.includes(val));
                            
                            // Recreate buttons
                            mcqOptionsDiv.innerHTML = letters.map(letter => `
                                <button type="button" 
                                        class="mcq-button ${selectedValues.includes(letter) ? 'selected' : ''}"
                                        data-section="${sectionId}"
                                        data-value="${letter}"
                                        onclick="selectMixedMCQ('${sectionId}', '${letter}', ${questionNum})">
                                    ${letter}
                                </button>
                            `).join('');
                        }
                    }
                });
                
                unsavedChanges = true;
                document.getElementById('unsaved-changes').style.display = 'inline';
                document.getElementById(`saved-${questionNum}`).style.display = 'none';
            });
        }
    }
}

// Helper function to mark as unsaved
function markUnsaved(questionNum) {
    unsavedChanges = true;
    document.getElementById('unsaved-changes').style.display = 'inline';
    document.getElementById(`saved-${questionNum}`).style.display = 'none';
}

// MCQ selection (now supports multiple answers)
function selectMCQ(questionNum, letter) {
    const button = event.target;
    const hiddenInput = document.getElementById(`answer-${questionNum}`);
    const isMultiple = button.dataset.multiple === 'true';
    let currentAnswers = hiddenInput.value.split(',').filter(a => a.trim()).map(a => a.toUpperCase());
    
    if (isMultiple) {
        // Toggle selection for multiple answers
        if (button.classList.contains('selected')) {
            button.classList.remove('selected');
            currentAnswers = currentAnswers.filter(a => a !== letter);
        } else {
            button.classList.add('selected');
            if (!currentAnswers.includes(letter)) {
                currentAnswers.push(letter);
            }
        }
    } else {
        // Single selection - clear others first
        document.querySelectorAll(`[data-question="${questionNum}"].mcq-button`).forEach(btn => {
            btn.classList.remove('selected');
        });
        button.classList.add('selected');
        currentAnswers = [letter];
    }
    
    // Sort answers alphabetically
    currentAnswers.sort();
    
    // Update hidden input
    const newValue = currentAnswers.join(',');
    hiddenInput.value = newValue;
    answers[questionNum] = newValue;
    markUnsaved(questionNum);
}

// Update checkboxes
function updateCheckboxes(questionNum) {
    const checkboxes = document.querySelectorAll(`#answer-container-${questionNum} input[type="checkbox"]:checked`);
    const values = Array.from(checkboxes).map(cb => cb.value).join(',');
    document.getElementById(`answer-${questionNum}`).value = values;
    answers[questionNum] = values;
    markUnsaved(questionNum);
}

// Update short answers
function updateShortAnswers(questionNum) {
    const inputs = document.querySelectorAll(`#responses-${questionNum} input[type="text"]`);
    const values = Array.from(inputs).map(input => input.value).filter(v => v.trim()).join('|');
    document.getElementById(`answer-${questionNum}`).value = values;
    answers[questionNum] = values;
    
    // Update options_count to match actual number of responses
    const optionsCountField = document.getElementById(`options-count-${questionNum}`);
    if (optionsCountField) {
        const actualCount = inputs.length;
        if (optionsCountField.value != actualCount) {
            optionsCountField.value = actualCount;
        }
    }
    
    markUnsaved(questionNum);
}

// Add response for short answer
function addResponse(questionNum) {
    const container = document.getElementById(`responses-${questionNum}`);
    const responseCount = container.querySelectorAll('.response-item').length;
    const newResponse = document.createElement('div');
    newResponse.className = 'response-item';
    newResponse.innerHTML = `
        <input type="text" 
               placeholder="Acceptable response ${responseCount + 1}"
               onchange="updateShortAnswers(${questionNum})">
        <button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>
    `;
    container.appendChild(newResponse);
    
    // Update options_count
    const optionsCountField = document.getElementById(`options-count-${questionNum}`);
    if (optionsCountField) {
        optionsCountField.value = responseCount + 1;
    }
    
    updateShortAnswers(questionNum);
}

// Remove response for short/long answer
function removeResponse(questionNum, button) {
    button.parentElement.remove();
    
    // Check if it's a long answer by looking for textareas
    const container = document.getElementById(`responses-${questionNum}`);
    if (container.querySelector('textarea')) {
        updateLongAnswers(questionNum);
    } else {
        updateShortAnswers(questionNum);
        
        // Update options_count after removal
        const optionsCountField = document.getElementById(`options-count-${questionNum}`);
        if (optionsCountField) {
            const inputs = container.querySelectorAll('input[type="text"]');
            optionsCountField.value = inputs.length;
        }
    }
}

// Toggle multiple answers checkbox
function toggleMultipleAnswers(questionNum) {
    const isMultiple = document.getElementById(`multi-${questionNum}`).checked;
    const buttons = document.querySelectorAll(`[data-question="${questionNum}"].mcq-button`);
    
    buttons.forEach(btn => {
        btn.dataset.multiple = isMultiple;
    });
    
    // Update help text
    const helpText = document.getElementById(`mcq-help-${questionNum}`);
    if (helpText) {
        helpText.textContent = isMultiple ? 
            'Click to select correct answer(s) - multiple selections allowed' : 
            'Click to select the correct answer';
    }
    
    // If switching to single answer, keep only first selected
    if (!isMultiple) {
        const hiddenInput = document.getElementById(`answer-${questionNum}`);
        const currentAnswers = hiddenInput.value.split(',').filter(a => a.trim());
        if (currentAnswers.length > 1) {
            hiddenInput.value = currentAnswers[0];
            answers[questionNum] = currentAnswers[0];
            
            // Update visual selection
            buttons.forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.value === currentAnswers[0]) {
                    btn.classList.add('selected');
                }
            });
        }
    }
    
    markUnsaved(questionNum);
}

// Update options count
function updateOptionsCount(questionNum) {
    const newCount = parseInt(document.getElementById(`options-count-${questionNum}`).value);
    updateAnswerInput(questionNum, 'MCQ');
    markUnsaved(questionNum);
}

// Update long answers
function updateLongAnswers(questionNum) {
    const textareas = document.querySelectorAll(`#responses-${questionNum} textarea`);
    const values = Array.from(textareas).map(ta => ta.value).filter(v => v.trim()).join('|||');
    document.getElementById(`answer-${questionNum}`).value = values;
    answers[questionNum] = values;
    markUnsaved(questionNum);
}

// Add long response
function addLongResponse(questionNum) {
    const container = document.getElementById(`responses-${questionNum}`);
    const responseCount = container.querySelectorAll('.response-item').length;
    const newResponse = document.createElement('div');
    newResponse.className = 'response-item';
    newResponse.innerHTML = `
        <textarea placeholder="Grading guideline or sample answer ${responseCount + 1}"
                  onchange="updateLongAnswers(${questionNum})"
                  style="min-height: 80px; width: 100%;"></textarea>
        <button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>
    `;
    container.appendChild(newResponse);
}

// Add mixed section
function addMixedSection(questionNum, type) {
    const container = document.getElementById(`mixed-sections-${questionNum}`);
    const sectionId = `mixed-${questionNum}-${Date.now()}`;
    
    let sectionHtml = '';
    const sectionDiv = document.createElement('div');
    sectionDiv.className = 'mixed-answer-section';
    sectionDiv.id = sectionId;
    
    switch(type) {
        case 'MCQ':
            // Get the current options count for this MIXED question
            const optionsCountSelector = document.getElementById(`mixed-options-count-${questionNum}`);
            const optionsCount = optionsCountSelector ? parseInt(optionsCountSelector.value) : 5;
            const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, optionsCount);
            
            sectionDiv.innerHTML = `
                <div class="mixed-type-header">
                    <span class="mixed-type-label">Multiple Choice</span>
                    <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                </div>
                <div class="mcq-options">
                    ${letters.map(letter => `
                        <button type="button" 
                                class="mcq-button"
                                data-section="${sectionId}"
                                data-value="${letter}"
                                onclick="selectMixedMCQ('${sectionId}', '${letter}', ${questionNum})">
                            ${letter}
                        </button>
                    `).join('')}
                </div>
            `;
            break;
            
        case 'SHORT':
            sectionDiv.innerHTML = `
                <div class="mixed-type-header">
                    <span class="mixed-type-label">Short Answer</span>
                    <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                </div>
                <input type="text" 
                       placeholder="Enter acceptable answer"
                       onchange="updateMixedAnswers(${questionNum})"
                       style="width: 100%; padding: 8px;">
            `;
            break;
            
        case 'LONG':
            sectionDiv.innerHTML = `
                <div class="mixed-type-header">
                    <span class="mixed-type-label">Long Answer</span>
                    <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                </div>
                <textarea placeholder="Enter grading guidelines"
                          onchange="updateMixedAnswers(${questionNum})"
                          style="width: 100%; min-height: 80px; padding: 8px;"></textarea>
            `;
            break;
    }
    
    container.appendChild(sectionDiv);
    updateMixedAnswers(questionNum);
}

// Remove mixed section
function removeMixedSection(sectionId, questionNum) {
    document.getElementById(sectionId).remove();
    updateMixedAnswers(questionNum);
}

// Update mixed answers
function updateMixedAnswers(questionNum) {
    const sections = document.querySelectorAll(`#mixed-sections-${questionNum} .mixed-answer-section`);
    const mixedData = [];
    
    sections.forEach(section => {
        const typeLabel = section.querySelector('.mixed-type-label').textContent;
        let value = '';
        
        if (typeLabel === 'Multiple Choice') {
            const selected = Array.from(section.querySelectorAll('.mcq-button.selected'))
                .map(btn => btn.dataset.value);
            value = selected.join(',');
        } else if (typeLabel === 'Short Answer') {
            value = section.querySelector('input').value;
        } else if (typeLabel === 'Long Answer') {
            value = section.querySelector('textarea').value;
        }
        
        if (value) {
            mixedData.push({type: typeLabel, value: value});
        }
    });
    
    const jsonValue = JSON.stringify(mixedData);
    document.getElementById(`answer-${questionNum}`).value = jsonValue;
    answers[questionNum] = jsonValue;
    markUnsaved(questionNum);
}

// Select MCQ in mixed section
function selectMixedMCQ(sectionId, letter, questionNum) {
    const button = event.target;
    button.classList.toggle('selected');
    updateMixedAnswers(questionNum);
}

// Initialize mixed question from saved data
function initializeMixedQuestion(questionNum, mixedData) {
    const container = document.getElementById(`mixed-sections-${questionNum}`);
    if (!container) return;
    
    container.innerHTML = ''; // Clear existing content
    
    mixedData.forEach(section => {
        const sectionId = `mixed-${questionNum}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'mixed-answer-section';
        sectionDiv.id = sectionId;
        
        switch(section.type) {
            case 'Multiple Choice':
                // Get the current options count for this MIXED question
                const optionsCountSelector = document.getElementById(`mixed-options-count-${questionNum}`);
                const optionsCount = optionsCountSelector ? parseInt(optionsCountSelector.value) : 5;
                const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, optionsCount);
                
                sectionDiv.innerHTML = `
                    <div class="mixed-type-header">
                        <span class="mixed-type-label">Multiple Choice</span>
                        <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                    </div>
                    <div class="mcq-options">
                        ${letters.map(letter => `
                            <button type="button" 
                                    class="mcq-button ${section.value && section.value.includes(letter) ? 'selected' : ''}"
                                    data-section="${sectionId}"
                                    data-value="${letter}"
                                    onclick="selectMixedMCQ('${sectionId}', '${letter}', ${questionNum})">
                                ${letter}
                            </button>
                        `).join('')}
                    </div>
                `;
                break;
                
            case 'Short Answer':
                sectionDiv.innerHTML = `
                    <div class="mixed-type-header">
                        <span class="mixed-type-label">Short Answer</span>
                        <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                    </div>
                    <input type="text" 
                           value="${section.value || ''}"
                           placeholder="Enter acceptable answer"
                           onchange="updateMixedAnswers(${questionNum})"
                           style="width: 100%; padding: 8px;">
                `;
                break;
                
            case 'Long Answer':
                sectionDiv.innerHTML = `
                    <div class="mixed-type-header">
                        <span class="mixed-type-label">Long Answer</span>
                        <button type="button" class="remove-section-btn" onclick="removeMixedSection('${sectionId}', ${questionNum})">Remove</button>
                    </div>
                    <textarea placeholder="Enter grading guidelines"
                              onchange="updateMixedAnswers(${questionNum})"
                              style="width: 100%; min-height: 80px; padding: 8px;">${section.value || ''}</textarea>
                `;
                break;
        }
        
        container.appendChild(sectionDiv);
    });
}

// Toggle audio for a question
function toggleAudio(questionNum) {
    console.log('Current audio assignments:', audioAssignments);
    console.log('Toggling audio for question:', questionNum);
    
    // Get existing audio files for this exam (for assignment interface only)
    const audioFiles = [
        {% for audio in exam.audio_files.all %}
        {
            id: {{ audio.id }},
            name: "{{ audio.name|escapejs }}",
            url: "{% url 'PlacementTest:get_audio' audio.id %}",
            filename: "{{ audio.audio_file.name|escapejs }}"
        },
        {% endfor %}
    ];
    
    if (audioFiles.length === 0) {
        alert('No audio files have been uploaded for this exam.\n\nTo add audio files:\n1. Go to Exam List\n2. Click "Upload New Exam" to create a new exam with audio files');
        return;
    }
    
    // Check if this question has an assigned audio (from our tracking)
    const currentAssignedAudioId = audioAssignments[questionNum];
    let currentAssignedAudio = null;
    if (currentAssignedAudioId) {
        currentAssignedAudio = audioFiles.find(a => a.id === currentAssignedAudioId);
    }
    
    // Current assignment is already handled by audioAssignments object
    
    // Build audio list with clear indication of current assignment
    let audioList = 'üéµ ASSIGN AUDIO TO QUESTION ' + questionNum + '\n';
    audioList += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
    audioList += 'Available Audio Files:\n';
    audioFiles.forEach((audio, index) => {
        // Display the audio name, or extract filename if name is generic
        let displayName = audio.name;
        if (displayName === 'Audio File' || displayName.startsWith('Audio ')) {
            // Extract filename from path and remove extension
            const parts = audio.filename.split('/');
            const filename = parts[parts.length - 1];
            displayName = filename.replace(/\.[^/.]+$/, ''); // Remove extension
        }
        
        // Check localStorage for updated name
    const storedAudioNames = JSON.parse(localStorage.getItem(`exam_${examId}_audio_names`) || '{}');
    const storedName = storedAudioNames[audio.id];
    if (storedName) {
        displayName = storedName;
    }
    
    audioList += `${index + 1}. ${displayName}`;
        if (currentAssignedAudio && currentAssignedAudio.id === audio.id) {
            audioList += ' ‚Üê CURRENTLY ASSIGNED';
        }
        audioList += '\n';
    });
    
    audioList += '\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
    audioList += 'To assign audio: Enter the number (1-' + audioFiles.length + ')\n';
    audioList += 'To remove audio: Enter 0\n';
    audioList += 'To cancel: Click Cancel\n\n';
    audioList += 'Example: Enter "2" to assign "ss" to this question';
    
    const choice = prompt(audioList);
    if (choice !== null && choice !== '') {
        const choiceNum = parseInt(choice);
        if (choiceNum === 0) {
            // Remove assignment
            removeAudioAssignment(questionNum);
        } else if (!isNaN(choiceNum)) {
            const index = choiceNum - 1;
            if (index >= 0 && index < audioFiles.length) {
                const selectedAudio = audioFiles[index];
                assignAudioToQuestion(questionNum, selectedAudio);
            }
        }
    }
}

// Assign audio to question
function assignAudioToQuestion(questionNum, audio) {
    console.log('Assigning audio:', audio, 'to question:', questionNum);
    
    // Track the assignment
    audioAssignments[questionNum] = audio.id;
    
    // Get the display name from localStorage or use original
    const cachedAudioNames = JSON.parse(localStorage.getItem(`exam_${examId}_audio_names`) || '{}');
    const displayName = cachedAudioNames[audio.id] || audio.name;
    console.log('Display name:', displayName, 'for audio ID:', audio.id);
    
    // Update the UI
    const button = document.querySelector(`[data-question="${questionNum}"].audio-button`);
    if (button) {
        button.classList.add('has-audio');
        // Update button text to show which audio is assigned
        const shortName = displayName.substring(0, 20) + (displayName.length > 20 ? '...' : '');
        button.innerHTML = `üéµ Audio: ${shortName}`;
    }
    
    // Mark as unsaved
    markUnsaved(questionNum);
    
    // Show confirmation
    alert(`Audio "${displayName}" assigned to Question ${questionNum}!\n\nNote: This assignment is temporary. Click "Save All" to save changes.`);
}

// Remove audio assignment
function removeAudioAssignment(questionNum) {
    // Remove from tracking
    delete audioAssignments[questionNum];
    
    // Update the UI
    const button = document.querySelector(`[data-question="${questionNum}"].audio-button`);
    if (button) {
        button.classList.remove('has-audio');
        button.innerHTML = 'üéµ Audio';
    }
    
    // Mark as unsaved
    markUnsaved(questionNum);
    
    alert(`Audio assignment removed from Question ${questionNum}.`);
}

function saveAnswer(questionNum, answer) {
    // This would make an API call to save individual answer
    // For now, we'll just show the saved indicator
    document.getElementById(`saved-${questionNum}`).style.display = 'inline';
}

function saveAllAnswers() {
    console.log('[SAVE_ALL] ========================================');
    console.log('[SAVE_ALL] Starting comprehensive save process');
    console.log('[SAVE_ALL] Timestamp:', new Date().toISOString());
    
    const questionsData = [];
    
    // Check if there are unsaved audio name changes
    const hasUnsavedAudioNames = changedAudioNames.size > 0;
    console.log('[SAVE_ALL] Unsaved audio names:', hasUnsavedAudioNames, 'Count:', changedAudioNames.size);
    
    // Prepare audio names to save if there are changes
    let audioNamesToSave = {};
    if (hasUnsavedAudioNames) {
        console.log('[SAVE_ALL] Collecting audio names to save...');
        changedAudioNames.forEach(audioId => {
            const nameInput = document.getElementById(`audio-name-${audioId}`);
            if (nameInput) {
                const newName = nameInput.value.trim();
                audioNamesToSave[audioId] = newName;
                localAudioNames[audioId] = newName;
                console.log(`[SAVE_ALL] Audio ${audioId}: "${newName}"`);
            }
        });
    }
    
    document.querySelectorAll('.question-entry').forEach(entry => {
        const questionNum = entry.dataset.questionNumber;
        const questionId = entry.dataset.questionId;
        const answerField = entry.querySelector('.answer-field');
        const typeSelect = entry.querySelector('.question-type-select');
        const optionsCount = document.getElementById(`options-count-${questionNum}`);
        
        let correctAnswer = answerField.value;
        
        // For SHORT answers, collect from multiple input fields
        if (typeSelect.value === 'SHORT') {
            const responseContainer = document.getElementById(`responses-${questionNum}`);
            if (responseContainer) {
                const inputs = responseContainer.querySelectorAll('input[type="text"]');
                if (inputs.length > 0) {
                    const values = Array.from(inputs).map(input => input.value).filter(v => v.trim());
                    correctAnswer = values.join('|');
                }
            }
        }
        
        // For LONG answers, collect from multiple textareas
        if (typeSelect.value === 'LONG') {
            const responseContainer = document.getElementById(`responses-${questionNum}`);
            if (responseContainer) {
                const textareas = responseContainer.querySelectorAll('textarea');
                if (textareas.length > 0) {
                    const values = Array.from(textareas).map(ta => ta.value).filter(v => v.trim());
                    correctAnswer = values.join('|||');
                }
            }
        }
        
        // For MIXED answers, collect the JSON data
        if (typeSelect.value === 'MIXED') {
            const sections = document.querySelectorAll(`#mixed-sections-${questionNum} .mixed-answer-section`);
            const mixedData = [];
            
            sections.forEach(section => {
                const typeLabel = section.querySelector('.mixed-type-label').textContent;
                let value = '';
                
                if (typeLabel === 'Multiple Choice') {
                    const selected = Array.from(section.querySelectorAll('.mcq-button.selected'))
                        .map(btn => btn.dataset.value);
                    value = selected.join(',');
                } else if (typeLabel === 'Short Answer') {
                    value = section.querySelector('input').value;
                } else if (typeLabel === 'Long Answer') {
                    value = section.querySelector('textarea').value;
                }
                
                if (value) {
                    mixedData.push({type: typeLabel, value: value});
                }
            });
            
            correctAnswer = JSON.stringify(mixedData);
        }
        
        // CRITICAL FIX: Collect current points value for Save All
        let currentPoints = null;
        
        // Try to get points from the points input (if in edit mode)
        const pointsInput = entry.querySelector('.points-input');
        if (pointsInput) {
            currentPoints = parseInt(pointsInput.value);
            console.log(`[SaveAll] Found points input for Q${questionNum}: ${currentPoints} points`);
        }
        
        // If not in edit mode, get from display
        if (currentPoints === null) {
            const pointsDisplay = entry.querySelector('.question-points-display');
            if (pointsDisplay) {
                // Extract number from text like "5 points" or "1 point"
                const pointsText = pointsDisplay.textContent.trim();
                const match = pointsText.match(/^(\d+)\s+point/);
                if (match) {
                    currentPoints = parseInt(match[1]);
                    console.log(`[SaveAll] Found points display for Q${questionNum}: ${currentPoints} points`);
                } else {
                    console.warn(`[SaveAll] Could not parse points from display text: "${pointsText}"`);
                }
            }
        }
        
        // Validate points value
        if (currentPoints !== null && (currentPoints < 1 || currentPoints > 10)) {
            console.warn(`[SaveAll] Invalid points value for Q${questionNum}: ${currentPoints}, using default of 1`);
            currentPoints = 1;
        }
        
        const data = {
            id: questionId,
            question_number: questionNum,
            question_type: typeSelect.value,
            correct_answer: correctAnswer
        };
        
        // CRITICAL: Include points in the data sent to backend
        if (currentPoints !== null) {
            data.points = currentPoints;
            console.log(`[SaveAll] Including points for Q${questionNum}: ${currentPoints}`);
        } else {
            console.warn(`[SaveAll] No points value found for Q${questionNum}, backend will use existing value`);
        }
        
        // Add options count for MCQ, CHECKBOX, and SHORT question types
        if ((typeSelect.value === 'MCQ' || typeSelect.value === 'CHECKBOX' || typeSelect.value === 'SHORT') && optionsCount) {
            data.options_count = parseInt(optionsCount.value);
        }
        
        questionsData.push(data);
    });
    
    // Enhanced debugging for Save All
    const saveUrl = `/api/PlacementTest/exams/{{ exam.id }}/save-answers/`;
    console.log('[SaveAll] ============ SAVE ALL DEBUG ============');
    console.log('[SaveAll] Saving to URL:', saveUrl);
    console.log('[SaveAll] Total questions:', questionsData.length);
    
    // Log points summary
    const pointsSummary = questionsData.map(q => ({
        num: q.question_number,
        points: q.points || 'not set',
        type: q.question_type
    }));
    console.table(pointsSummary);
    
    console.log('[SaveAll] Full data being sent:', questionsData);
    console.log('[SaveAll] Audio assignments being saved:', audioAssignments);
    console.log('[SaveAll] =========================================');
    
    // Make API call to save all answers and types INCLUDING audio assignments and PDF rotation
    fetch(saveUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
            questions: questionsData,
            audio_assignments: audioAssignments,
            pdf_rotation: currentRotation  // Include current PDF rotation
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('[SaveAll] ============ SAVE RESPONSE ============');
        console.log('[SaveAll] Response data:', data);
        
        if (data.success) {
            // Log points update summary
            if (data.points_updated !== undefined) {
                console.log(`[SaveAll] ‚úÖ Points updated for ${data.points_updated} questions`);
                if (data.debug_info && data.debug_info.points_provided) {
                    console.log('[SaveAll] Questions with points updated:', data.debug_info.points_provided);
                }
            }
            
            unsavedChanges = false;
            document.getElementById('unsaved-changes').style.display = 'none';
            
            // Show the prominent success notification
            const notification = document.getElementById('success-notification');
            const alertDiv = notification.querySelector('.alert');
            notification.style.display = 'block';
            
            // Enhance success message with points info
            if (data.points_updated > 0) {
                const successText = alertDiv.querySelector('h4') || alertDiv;
                const originalText = successText.innerHTML;
                successText.innerHTML = `${originalText} (${data.points_updated} question points updated)`;
            }
            
            // Apply animations
            alertDiv.style.animation = 'slideDown 0.5s ease-out, pulse 2s ease-in-out';
            
            // Scroll to top to ensure notification is visible
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('[SaveAll] =========================================');
            
            // Force page refresh after brief success display to clear any browser cache
            setTimeout(() => {
                console.log('üîÑ Refreshing page to ensure latest data is displayed');
                window.location.reload(true); // Hard refresh to bypass cache
            }, 2000);
            
            // Also show the small save indicators
            document.querySelectorAll('.save-indicator').forEach(indicator => {
                indicator.style.display = 'inline';
            });
            
            // Auto-hide the notification after 8 seconds
            setTimeout(() => {
                const notif = document.getElementById('success-notification');
                const alert = notif.querySelector('.alert');
                alert.style.transition = 'opacity 0.5s ease-out';
                alert.style.opacity = '0';
                setTimeout(() => {
                    notif.style.display = 'none';
                    alert.style.opacity = '1';
                }, 500);
            }, 8000);
            
            // Hide small indicators after 3 seconds
            setTimeout(() => {
                document.querySelectorAll('.save-indicator').forEach(indicator => {
                    indicator.style.display = 'none';
                });
            }, 3000);
        } else {
            console.error('Save error:', data);
            alert('Error saving answers: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Save request failed:', error);
        alert('Error saving answers: ' + error.message);
    });
}

function clearAllAnswers() {
    if (confirm('Are you sure you want to clear all answers?')) {
        document.querySelectorAll('.answer-field').forEach(input => {
            input.value = '';
        });
        unsavedChanges = true;
        document.getElementById('unsaved-changes').style.display = 'inline';
        document.querySelectorAll('.save-indicator').forEach(indicator => {
            indicator.style.display = 'none';
        });
    }
}

// Randomize answers for QA testing
function randomizeAnswers() {
    if (!confirm('This will randomize all answers for QA testing. Continue?')) {
        return;
    }
    
    document.querySelectorAll('.question-entry').forEach(entry => {
        const questionNum = entry.dataset.questionNumber;
        const typeSelect = entry.querySelector('.question-type-select');
        const questionType = typeSelect.value;
        
        switch(questionType) {
            case 'MCQ':
                // For MCQ, randomly select answer(s)
                const isMultiple = document.getElementById(`multi-${questionNum}`)?.checked || false;
                const optionsCount = parseInt(document.getElementById(`options-count-${questionNum}`)?.value || 5);
                const availableOptions = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(0, optionsCount);
                
                // Clear all selections first
                document.querySelectorAll(`[data-question="${questionNum}"].mcq-button`).forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                if (isMultiple) {
                    // Select 1-3 random answers for multiple choice
                    const numAnswers = Math.floor(Math.random() * 3) + 1;
                    const selectedAnswers = [];
                    for (let i = 0; i < numAnswers; i++) {
                        const randomIndex = Math.floor(Math.random() * availableOptions.length);
                        const option = availableOptions[randomIndex];
                        if (!selectedAnswers.includes(option)) {
                            selectedAnswers.push(option);
                            const btn = document.querySelector(`[data-question="${questionNum}"][data-value="${option}"]`);
                            if (btn) btn.classList.add('selected');
                        }
                    }
                    document.getElementById(`answer-${questionNum}`).value = selectedAnswers.sort().join(',');
                } else {
                    // Select one random answer
                    const randomOption = availableOptions[Math.floor(Math.random() * availableOptions.length)];
                    const btn = document.querySelector(`[data-question="${questionNum}"][data-value="${randomOption}"]`);
                    if (btn) btn.classList.add('selected');
                    document.getElementById(`answer-${questionNum}`).value = randomOption;
                }
                break;
                
            case 'SHORT':
                // Generate random short answers
                const shortAnswers = [
                    ['answer', 'response', 'solution'],
                    ['cat', 'dog', 'bird'],
                    ['red', 'blue', 'green'],
                    ['yes', 'correct', 'true'],
                    ['10', 'ten', '10.0']
                ];
                const randomShortSet = shortAnswers[Math.floor(Math.random() * shortAnswers.length)];
                
                // Clear existing responses
                const shortContainer = document.getElementById(`responses-${questionNum}`);
                shortContainer.innerHTML = '';
                
                // Add random responses
                randomShortSet.forEach((answer, index) => {
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'response-item';
                    responseDiv.innerHTML = `
                        <input type="text" 
                               value="${answer}"
                               placeholder="Acceptable response ${index + 1}"
                               onchange="updateShortAnswers(${questionNum})">
                        ${index > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                    `;
                    shortContainer.appendChild(responseDiv);
                });
                updateShortAnswers(questionNum);
                break;
                
            case 'LONG':
                // Generate random grading guidelines
                const guidelines = [
                    'Student should demonstrate clear understanding of the concept',
                    'Answer must include specific examples',
                    'Response should be 2-3 paragraphs',
                    'Must reference the main topic',
                    'Should show critical thinking'
                ];
                
                // Clear existing responses
                const longContainer = document.getElementById(`responses-${questionNum}`);
                longContainer.innerHTML = '';
                
                // Add 2-3 random guidelines
                const numGuidelines = Math.floor(Math.random() * 2) + 2;
                for (let i = 0; i < numGuidelines; i++) {
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'response-item';
                    const guideline = guidelines[Math.floor(Math.random() * guidelines.length)];
                    responseDiv.innerHTML = `
                        <textarea placeholder="Grading guideline or sample answer ${i + 1}"
                                  onchange="updateLongAnswers(${questionNum})"
                                  style="min-height: 80px; width: 100%;">${guideline}</textarea>
                        ${i > 0 ? `<button type="button" class="remove-response" onclick="removeResponse(${questionNum}, this)">Remove</button>` : ''}
                    `;
                    longContainer.appendChild(responseDiv);
                }
                updateLongAnswers(questionNum);
                break;
                
            case 'MIXED':
                // For mixed type, add random sections
                const mixedContainer = document.getElementById(`mixed-sections-${questionNum}`);
                mixedContainer.innerHTML = '';
                
                // Add MCQ section
                addMixedSection(questionNum, 'MCQ');
                setTimeout(() => {
                    const mcqSection = mixedContainer.querySelector('.mcq-button');
                    if (mcqSection) {
                        mcqSection.click(); // Select option A
                    }
                }, 100);
                
                // Add short answer section
                addMixedSection(questionNum, 'SHORT');
                setTimeout(() => {
                    const shortInput = mixedContainer.querySelector('input[type="text"]');
                    if (shortInput) {
                        shortInput.value = 'Sample answer';
                        updateMixedAnswers(questionNum);
                    }
                }, 200);
                break;
        }
        
        markUnsaved(questionNum);
    });
    
    alert('Answers have been randomized for QA testing!');
}

// Mark audio name as changed
function markAudioNameChanged(audioId) {
    changedAudioNames.add(audioId);
    document.getElementById(`audio-saved-${audioId}`).style.display = 'none';
    
    // Store the local name
    const nameInput = document.getElementById(`audio-name-${audioId}`);
    if (nameInput) {
        localAudioNames[audioId] = nameInput.value.trim();
    }
}

// Delete audio file from exam
function renameAudioFile(audioId) {
    const input = document.getElementById(`audio-name-${audioId}`);
    const currentName = input.value;
    const newName = prompt('Enter new name for this audio file:', currentName);
    
    if (newName && newName !== currentName) {
        input.value = newName;
        markAudioNameChanged(audioId);
    }
}

function deleteAudioFile(audioId) {
    if (!confirm('Are you sure you want to remove this audio file from the exam?')) {
        return;
    }
    
    // Make API call to delete audio
    fetch(`/api/PlacementTest/exams/{{ exam.id }}/audio/${audioId}/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Remove the audio item from the UI
            const audioItem = document.getElementById(`audio-item-${audioId}`);
            if (audioItem) {
                audioItem.remove();
            }
            
            // Remove from local tracking
            delete localAudioNames[audioId];
            changedAudioNames.delete(audioId);
            
            alert('Audio file removed from exam successfully!');
            
            // If no audio files left, hide the entire section
            const audioSection = document.querySelector('.audio-files-section');
            const remainingItems = audioSection.querySelectorAll('.audio-file-item');
            if (remainingItems.length === 0) {
                audioSection.style.display = 'none';
            }
        } else {
            alert('Error removing audio file: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Delete request failed:', error);
        alert('Error removing audio file: ' + error.message);
    });
}

// Save all audio names (locally for this exam view only)
function saveAllAudioNames() {
    if (changedAudioNames.size === 0) {
        alert('No audio names have been changed.');
        return;
    }
    
    // Save to localStorage for this specific exam
    const storageKey = `exam_${examId}_audio_names`;
    
    // Update localAudioNames with all current values
    changedAudioNames.forEach(audioId => {
        const nameInput = document.getElementById(`audio-name-${audioId}`);
        if (nameInput) {
            localAudioNames[audioId] = nameInput.value.trim();
        }
    });
    
    // Save to localStorage
    localStorage.setItem(storageKey, JSON.stringify(localAudioNames));
    
    // Clear the changed set and show saved indicators
    changedAudioNames.forEach(audioId => {
        document.getElementById(`audio-saved-${audioId}`).style.display = 'inline';
    });
    changedAudioNames.clear();
    
    // Update audio buttons in the answer section
    updateAudioButtonNames();
    
    // Hide saved indicators after 3 seconds
    setTimeout(() => {
        document.querySelectorAll('.audio-save-indicator').forEach(indicator => {
            indicator.style.display = 'none';
        });
    }, 3000);
    
    alert('Audio display names saved locally for this exam!');
}

// Load local audio names from localStorage
function loadLocalAudioNames() {
    const storageKey = `exam_${examId}_audio_names`;
    const saved = localStorage.getItem(storageKey);
    
    if (saved) {
        try {
            // Check for corrupted localStorage values
            if (saved === 'null' || saved === 'undefined' || saved === '') {
                console.warn('Corrupted localStorage detected, clearing...');
                localStorage.removeItem(storageKey);
                return;
            }
            
            const savedNames = JSON.parse(saved);
            
            // Ensure savedNames is a valid object before using it
            if (savedNames && typeof savedNames === 'object' && !Array.isArray(savedNames)) {
                Object.assign(localAudioNames, savedNames);
                
                // Apply saved names to input fields
                Object.keys(savedNames).forEach(audioId => {
                    const input = document.getElementById(`audio-name-${audioId}`);
                    if (input) {
                        input.value = savedNames[audioId];
                    }
                });
            } else {
                console.warn('Invalid saved names format, clearing localStorage');
                localStorage.removeItem(storageKey);
            }
        } catch (e) {
            console.error('Error loading saved audio names:', e);
            // Clear corrupted data
            localStorage.removeItem(storageKey);
        }
    }
}

// Update audio button names after saving
function updateAudioButtonNames() {
    // Get the latest saved names from localStorage
    let savedNames = {};
    try {
        const stored = localStorage.getItem(`exam_${examId}_audio_names`);
        if (stored && stored !== 'null' && stored !== 'undefined') {
            savedNames = JSON.parse(stored);
        }
    } catch (e) {
        console.error('Error parsing saved names:', e);
        savedNames = {};
    }
    
    // Update all audio buttons based on current assignments
    if (audioAssignments && typeof audioAssignments === 'object') {
        Object.entries(audioAssignments).forEach(([questionNum, audioId]) => {
        const button = document.querySelector(`[data-question="${questionNum}"].audio-button`);
        if (button) {
            // Get the display name
            const displayName = savedNames[audioId] || 
                               document.getElementById(`audio-name-${audioId}`)?.value || 
                               'Audio ' + audioId;
            
            const shortName = displayName.substring(0, 20) + (displayName.length > 20 ? '...' : '');
            button.innerHTML = `üéµ Audio: ${shortName}`;
        }
    });
    }  // End of null check for audioAssignments
}



// IMMEDIATE DEBUG - This should appear in console as soon as JavaScript loads
console.log('üî¥ [CRITICAL DEBUG] JavaScript is loading! Timestamp:', new Date().toISOString());
console.log('üî¥ [CRITICAL DEBUG] Current URL:', window.location.href);
console.log('üî¥ [CRITICAL DEBUG] Page ready state:', document.readyState);

// CRITICAL FIX: Get CSRF token safely
function getCSRFToken() {
    // Try multiple methods to get CSRF token
    let token = null;
    
    // Method 1: From input field
    const tokenInput = document.querySelector('[name=csrfmiddlewaretoken]');
    if (tokenInput) {
        token = tokenInput.value;
        console.log('‚úÖ [CSRF] Token found in input field');
    }
    
    // Method 2: From cookie
    if (!token) {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        if (cookieValue) {
            token = cookieValue;
            console.log('‚úÖ [CSRF] Token found in cookie');
        }
    }
    
    // Method 3: From meta tag (if exists)
    if (!token) {
        const metaToken = document.querySelector('meta[name="csrf-token"]');
        if (metaToken) {
            token = metaToken.getAttribute('content');
            console.log('‚úÖ [CSRF] Token found in meta tag');
        }
    }
    
    if (!token) {
        console.warn('‚ö†Ô∏è [CSRF] No CSRF token found, API calls may fail');
    }
    
    return token || '';
}

console.log('üîç [CSRF] Checking for CSRF token...');
const csrfToken = getCSRFToken();
if (csrfToken) {
    console.log('‚úÖ [CSRF] Token available for API calls');
} else {
    console.error('‚ùå [CSRF] No token available - API calls will likely fail');
}

// NOTIFICATION SYSTEM - Comprehensive user feedback mechanism
let notificationContainer = null;
let notificationCount = 0;
const activeNotifications = new Map();

/**
 * Show a notification message to the user
 * @param {string} message - The message to display
 * @param {string} type - Type of notification: 'success', 'error', 'info', 'warning'
 * @param {number} duration - How long to show the notification (ms), 0 for permanent
 */
function showNotification(message, type = 'info', duration = 5000) {
    console.log(`[NOTIFICATION] üì¢ Showing ${type} notification: ${message}`);
    
    // Ensure notification container exists
    if (!notificationContainer) {
        notificationContainer = document.getElementById('notification-container');
        if (!notificationContainer) {
            // Create container if it doesn't exist
            notificationContainer = document.createElement('div');
            notificationContainer.id = 'notification-container';
            notificationContainer.className = 'notification-container';
            document.body.appendChild(notificationContainer);
            console.log('[NOTIFICATION] ‚úÖ Created notification container');
        }
    }
    
    // Create notification element
    const notificationId = `notification-${++notificationCount}`;
    const notification = document.createElement('div');
    notification.id = notificationId;
    notification.className = `notification-item ${type}`;
    
    // Build notification HTML
    notification.innerHTML = `
        <span class="notification-message">${message}</span>
        <button class="notification-close" onclick="dismissNotification('${notificationId}')">&times;</button>
        ${duration > 0 ? '<div class="notification-progress"></div>' : ''}
    `;
    
    // Add to container
    notificationContainer.appendChild(notification);
    activeNotifications.set(notificationId, notification);
    
    console.log(`[NOTIFICATION] ‚úÖ Added notification ${notificationId} to DOM`);
    
    // Auto-dismiss if duration is set
    if (duration > 0) {
        // Update progress bar animation duration
        const progressBar = notification.querySelector('.notification-progress');
        if (progressBar) {
            progressBar.style.animationDuration = `${duration}ms`;
        }
        
        // Set timeout for removal
        setTimeout(() => {
            dismissNotification(notificationId);
        }, duration);
        
        console.log(`[NOTIFICATION] ‚è±Ô∏è Auto-dismiss scheduled for ${notificationId} in ${duration}ms`);
    }
    
    // Log notification stats
    console.log(`[NOTIFICATION] üìä Active notifications: ${activeNotifications.size}`);
    
    return notificationId;
}

/**
 * Dismiss a specific notification
 * @param {string} notificationId - ID of the notification to dismiss
 */
function dismissNotification(notificationId) {
    console.log(`[NOTIFICATION] üóëÔ∏è Dismissing notification ${notificationId}`);
    
    const notification = activeNotifications.get(notificationId);
    if (notification) {
        // Add removing animation
        notification.classList.add('removing');
        
        // Remove after animation completes
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
            activeNotifications.delete(notificationId);
            console.log(`[NOTIFICATION] ‚úÖ Removed notification ${notificationId}`);
            console.log(`[NOTIFICATION] üìä Active notifications: ${activeNotifications.size}`);
        }, 300); // Match animation duration
    } else {
        console.warn(`[NOTIFICATION] ‚ö†Ô∏è Notification ${notificationId} not found`);
    }
}

/**
 * Clear all notifications
 */
function clearAllNotifications() {
    console.log(`[NOTIFICATION] üßπ Clearing all ${activeNotifications.size} notifications`);
    
    activeNotifications.forEach((notification, id) => {
        dismissNotification(id);
    });
}

// Test notification system on load (only in debug mode)
document.addEventListener('DOMContentLoaded', function() {
    console.log('[NOTIFICATION] üîß Notification system ready');
    
    // Show a test notification if in debug mode (can be removed in production)
    if (window.location.href.includes('debug=true')) {
        showNotification('‚úÖ Notification system initialized', 'success', 3000);
    }
});

console.log('[NOTIFICATION] ‚úÖ Notification system loaded and ready');

// VISUAL INDICATOR - Add a JavaScript status message to the page
(function() {
    const statusDiv = document.createElement('div');
    statusDiv.id = 'js-status-indicator';
    statusDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: #ffeb3b; color: #333; padding: 10px 15px; border-radius: 5px; font-weight: bold; z-index: 10000; box-shadow: 0 2px 5px rgba(0,0,0,0.2);';
    statusDiv.innerHTML = '‚ö†Ô∏è JavaScript Loading...';
    document.body.appendChild(statusDiv);
    console.log('üü° [STATUS] JavaScript status indicator added to page');
})();

// Points editing functionality
document.addEventListener('DOMContentLoaded', function() {
    console.log('[PointsEditor] üöÄ INITIALIZING POINTS EDITING SYSTEM');
    console.log('[PointsEditor] Timestamp:', new Date().toISOString());
    console.log('[PointsEditor] DOM fully loaded and parsed');
    console.log('[PointsEditor] Document ready state:', document.readyState);
    console.log('[PointsEditor] Body element exists:', !!document.body);
    console.log('[PointsEditor] CSRF Token available:', !!getCSRFToken());
    
    // Function to set up edit button event handlers
    function setupEditButtonHandlers() {
        const editButtons = document.querySelectorAll('.edit-points-btn');
        console.log(`[PointsEditor] üéØ Setting up handlers for ${editButtons.length} edit buttons`);
        
        // CRITICAL: Set up event handlers for EACH edit button
        editButtons.forEach((btn, index) => {
            console.log(`[PointsEditor] üîß Attaching handlers to button ${index + 1} for question ${btn.dataset.questionId}`);
            
            // CLICK HANDLER - Opens the edit interface
            btn.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                
                const questionId = this.dataset.questionId;
                const container = this.parentElement;
                const display = container.querySelector('.question-points-display');
                const editDiv = container.querySelector('.question-points-edit');
                const input = editDiv ? editDiv.querySelector('.points-input') : null;
                
                console.log(`[PointsEditor] üñ±Ô∏è CLICK: Edit button clicked for question ${questionId}`);
                console.log(`[PointsEditor] üìä Current points display:`, display ? display.textContent : 'NOT FOUND');
                console.log(`[PointsEditor] üîç DOM elements found:`, {
                    container: !!container,
                    display: !!display,
                    editDiv: !!editDiv,
                    input: !!input
                });
                
                // Validate all required elements exist
                if (!container || !display || !editDiv || !input) {
                    console.error(`[PointsEditor] ‚ùå Missing required elements for question ${questionId}`);
                    alert('Error: Required elements not found. Please refresh the page.');
                    return;
                }
                
                // Get current points value
                const currentPoints = input.value;
                console.log(`[PointsEditor] üìù Current input value: ${currentPoints}`);
                
                // Hide display, show edit interface
                display.style.display = 'none';
                editDiv.style.display = 'flex';
                this.style.display = 'none';
                
                console.log(`[PointsEditor] üëÅÔ∏è UI State Changed: display hidden, edit visible`);
                
                // Focus and select input
                try {
                    input.focus();
                    input.select();
                    console.log(`[PointsEditor] üìç Input focused and selected`);
                } catch (focusError) {
                    console.error(`[PointsEditor] ‚ùå Failed to focus input:`, focusError);
                }
            });
            
            // HOVER HANDLERS - Show impact preview tooltip
            let impactPreviewTimeout;
            let impactPreview = null;
            
            // MOUSEENTER - Show impact preview after delay
            btn.addEventListener('mouseenter', function() {
                const questionId = this.dataset.questionId;
                console.log(`[PointsEditor] üéØ HOVER: Mouse entered button for question ${questionId}`);
                
                // Clear any existing timeout
                if (impactPreviewTimeout) {
                    clearTimeout(impactPreviewTimeout);
                }
                
                // Show impact preview after 800ms delay
                impactPreviewTimeout = setTimeout(async () => {
                    console.log(`[ImpactPreview] üîç Loading impact preview for question ${questionId}`);
                    
                    try {
                        // Create preview element if it doesn't exist
                        if (!impactPreview) {
                            impactPreview = document.createElement('div');
                            impactPreview.className = 'points-impact-preview';
                            document.body.appendChild(impactPreview);
                            console.log('[ImpactPreview] üìù Created preview element');
                        }
                        
                        // Position the preview
                        const rect = btn.getBoundingClientRect();
                        const leftPos = (rect.left + rect.width / 2);
                        const topPos = (rect.bottom + window.scrollY);
                        
                        impactPreview.style.left = leftPos + 'px';
                        impactPreview.style.top = topPos + 'px';
                        
                        // Show loading state
                        impactPreview.innerHTML = `
                            <div class="impact-preview-header">Impact Preview</div>
                            <div class="impact-preview-loading">Loading...</div>
                        `;
                        impactPreview.classList.add('show');
                        
                        // Fetch impact data
                        const apiUrl = `/api/PlacementTest/questions/${questionId}/points/impact-preview/`;
                        console.log(`[ImpactPreview] üåê Fetching: ${apiUrl}`);
                        
                        const response = await fetch(apiUrl, {
                            method: 'GET',
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest',
                                'Accept': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        const data = await response.json();
                        console.log('[ImpactPreview] ‚úÖ Data received');
                        
                        // Display impact data
                        if (data.success && data.impact_analysis) {
                            const impact = data.impact_analysis;
                            let content = `<div class="impact-preview-header">Impact Preview</div>`;
                            content += `<div class="impact-preview-stats">`;
                            
                            if (impact.impact_summary.total_affected_sessions === 0) {
                                content += `<div class="impact-no-sessions">‚úÖ No sessions affected</div>`;
                            } else {
                                const summary = impact.impact_summary;
                                content += `<div class="impact-sessions-count">üìä ${summary.total_affected_sessions} sessions</div>`;
                                content += `<div>‚úÖ ${summary.sessions_with_correct_answers} correct</div>`;
                                content += `<div>‚ùå ${summary.sessions_with_incorrect_answers} incorrect</div>`;
                            }
                            
                            content += `</div>`;
                            impactPreview.innerHTML = content;
                        }
                        
                    } catch (error) {
                        console.error('[ImpactPreview] ‚ùå Error:', error);
                        if (impactPreview) {
                            impactPreview.innerHTML = `
                                <div class="impact-preview-header">Impact Preview</div>
                                <div class="impact-preview-stats">‚ùå Error loading</div>
                            `;
                        }
                    }
                }, 800);
            });
            
            // MOUSELEAVE - Hide impact preview
            btn.addEventListener('mouseleave', function() {
                console.log(`[PointsEditor] üëã HOVER: Mouse left button`);
                
                if (impactPreviewTimeout) {
                    clearTimeout(impactPreviewTimeout);
                }
                if (impactPreview) {
                    impactPreview.classList.remove('show');
                }
            });
            
            console.log(`[PointsEditor] ‚úÖ Button ${index + 1} configured with all handlers`);
        });
        
        console.log(`[PointsEditor] üéâ All ${editButtons.length} edit buttons configured`);
        
        // Update visual status indicator
        const statusDiv = document.getElementById('js-status-indicator');
        if (statusDiv) {
            statusDiv.style.background = '#4caf50';
            statusDiv.style.color = '#fff';
            statusDiv.innerHTML = `‚úÖ Points Editor Ready (${editButtons.length} buttons)`;
            console.log('üü¢ [STATUS] Visual indicator updated - Points editor ready');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusDiv.style.opacity = '0';
                setTimeout(() => statusDiv.remove(), 500);
            }, 5000);
        }
    }
    
    // Check if points editing elements exist
    console.log('[PointsEditor] üîç Checking for required DOM elements...');
    
    const allEditButtons = document.querySelectorAll('.edit-points-btn');
    const allPointsContainers = document.querySelectorAll('.question-points-container');
    const allPointsDisplays = document.querySelectorAll('.question-points-display');
    const allPointsEdits = document.querySelectorAll('.question-points-edit');
    
    console.log('[PointsEditor] üìä Initial element counts:');
    console.log(`  ‚Ä¢ Edit buttons: ${allEditButtons.length}`);
    console.log(`  ‚Ä¢ Containers: ${allPointsContainers.length}`);
    console.log(`  ‚Ä¢ Displays: ${allPointsDisplays.length}`);
    console.log(`  ‚Ä¢ Edit divs: ${allPointsEdits.length}`);
    
    if (allEditButtons.length === 0) {
        console.error('[PointsEditor] ‚ùå No edit buttons found! Attempting fallback...');
        
        // Update status indicator to show error
        const statusDiv = document.getElementById('js-status-indicator');
        if (statusDiv) {
            statusDiv.style.background = '#f44336';
            statusDiv.style.color = '#fff';
            statusDiv.innerHTML = '‚ùå No edit buttons found - checking for fallback...';
        }
        
        const questionEntries = document.querySelectorAll('.question-entry');
        console.log(`[PointsEditor] Question entries found: ${questionEntries.length}`);
        
        if (questionEntries.length > 0) {
            console.log('[PointsEditor] üîß FALLBACK: Adding missing edit buttons...');
            let buttonsAdded = 0;
            
            questionEntries.forEach(entry => {
                const container = entry.querySelector('.question-points-container');
                const questionId = entry.dataset.questionId;
                
                if (container && !container.querySelector('.edit-points-btn')) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'edit-points-btn';
                    editBtn.dataset.questionId = questionId;
                    editBtn.title = 'Edit points';
                    editBtn.innerHTML = '‚úèÔ∏è';
                    editBtn.style.display = 'inline-block';
                    editBtn.style.visibility = 'visible';
                    
                    container.appendChild(editBtn);
                    buttonsAdded++;
                    console.log(`[PointsEditor] ‚úÖ Added button for Q${questionId}`);
                }
            });
            
            if (buttonsAdded > 0) {
                console.log(`[PointsEditor] ‚úÖ Added ${buttonsAdded} buttons via fallback`);
                setupEditButtonHandlers();
            }
        }
    } else {
        console.log('[PointsEditor] ‚úÖ Edit buttons found. Setting up handlers...');
        setupEditButtonHandlers();
    }
    
    // ENHANCED: Save points buttons with comprehensive API integration
    document.querySelectorAll('.save-points-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
            const questionId = this.dataset.questionId;
            const container = this.parentElement.parentElement;
            const input = this.parentElement.querySelector('.points-input');
            const newPoints = parseInt(input.value);
            const originalPoints = parseInt(input.dataset.originalValue);
            
            // Enhanced validation with user feedback
            if (isNaN(newPoints)) {
                showNotification('Please enter a valid number for points', 'error');
                input.focus();
                return;
            }
            
            if (newPoints < 1 || newPoints > 10) {
                showNotification('Points must be between 1 and 10', 'error');
                input.focus();
                return;
            }
            
            if (newPoints === originalPoints) {
                showNotification('No change needed - points are already set to ' + newPoints, 'info');
                // Cancel the edit
                document.querySelector(`.cancel-points-btn[data-question-id="${questionId}"]`).click();
                return;
            }
            
            // Show loading state
            const saveBtn = this;
            const cancelBtn = this.nextElementSibling;
            const originalSaveText = saveBtn.innerHTML;
            const originalCancelText = cancelBtn.innerHTML;
            
            saveBtn.innerHTML = '‚è≥';
            saveBtn.disabled = true;
            cancelBtn.disabled = true;
            input.disabled = true;
            
            console.log(`[PointsEditor] Updating Q${questionId}: ${originalPoints} -> ${newPoints} points`);
            
            try {
                // Use the enhanced API endpoint
                // Get CSRF token safely
                const csrf = getCSRFToken();
                if (!csrf) {
                    console.error('[PointsEditor] ‚ùå No CSRF token available');
                    showNotification('‚ùå Security token missing. Please refresh the page.', 'error');
                    // Re-enable buttons
                    saveBtn.disabled = false;
                    cancelBtn.disabled = false;
                    input.disabled = false;
                    return;
                }
                
                const response = await fetch(`/api/PlacementTest/questions/${questionId}/update/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': csrf,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: `points=${newPoints}`
                });
                
                console.log(`[PointsEditor] üì° Response status: ${response.status}`);
                console.log(`[PointsEditor] üì° Response OK: ${response.ok}`);
                
                if (!response.ok) {
                    console.error(`[PointsEditor] ‚ùå HTTP error! status: ${response.status}`);
                    showNotification(`‚ùå Server error (${response.status}). Please try again.`, 'error');
                    // Re-enable buttons
                    saveBtn.disabled = false;
                    cancelBtn.disabled = false;
                    input.disabled = false;
                    return;
                }
                
                const data = await response.json();
                console.log('[PointsEditor] üì¶ Response data:', data);
                
                if (data.success) {
                    // Enhanced success handling with comprehensive feedback
                    console.log('[PointsEditor] ‚úÖ Points update successful:', data);
                    
                    // Get the actual values from the server response
                    const actualOldPoints = data.updates_applied?.points?.old_value || originalPoints;
                    const actualNewPoints = data.updates_applied?.points?.new_value || newPoints;
                    
                    console.log(`[PointsEditor] üìä Server confirmed: ${actualOldPoints} ‚Üí ${actualNewPoints} points`);
                    
                    // Update display elements
                    const display = container.querySelector('.question-points-display');
                    const editDiv = container.querySelector('.question-points-edit');
                    const editBtn = container.querySelector('.edit-points-btn');
                    
                    // Use the server-confirmed value
                    display.textContent = `${actualNewPoints} point${actualNewPoints !== 1 ? 's' : ''}`;
                    input.dataset.originalValue = actualNewPoints;
                    
                    // Show display, hide edit
                    display.style.display = 'inline';
                    editDiv.style.display = 'none';
                    editBtn.style.display = 'inline';
                    
                    // Create comprehensive success message using actual values
                    // Add defensive check for question_number
                    const questionNumber = data.question_number || data.question?.number || 'Unknown';
                    console.log('[PointsEditor] üîç Question number resolution:', {
                        'data.question_number': data.question_number,
                        'data.question?.number': data.question?.number,
                        'resolved': questionNumber
                    });
                    
                    let successMsg = `‚úÖ Question ${questionNumber} updated: ${actualOldPoints} ‚Üí ${actualNewPoints} points`;
                    
                    // Add session recalculation info if available
                    if (data.updates_applied && data.updates_applied.sessions_recalculated > 0) {
                        successMsg += ` (${data.updates_applied.sessions_recalculated} student sessions recalculated)`;
                        console.log('[PointsEditor] üìä Affected sessions:', data.debug_info?.affected_sessions);
                    }
                    
                    // Add performance info in debug mode
                    if (data.debug_info?.performance) {
                        const perf = data.debug_info.performance;
                        console.log(`[PointsEditor] ‚ö° Performance: ${perf.total_time_seconds}s total${perf.recalculation_time_seconds ? `, ${perf.recalculation_time_seconds}s for recalculation` : ''}`);
                    }
                    
                    showNotification(successMsg, 'success');
                    
                } else {
                    // Enhanced error handling with comprehensive debugging
                    console.error('[PointsEditor] ‚ùå Points update failed:', data);
                    
                    // Enhanced debugging for response structure
                    console.log('[PointsEditor] üêõ Debug - Error response structure:', {
                        'has_question_number': 'question_number' in data,
                        'has_question_id': 'question_id' in data,
                        'has_question': 'question' in data,
                        'has_error': 'error' in data,
                        'has_field': 'field' in data,
                        'response_keys': Object.keys(data),
                        'question_number_value': data.question_number,
                        'question_id_value': data.question_id
                    });
                    
                    let errorMsg = 'Failed to update points';
                    
                    if (data.error) {
                        errorMsg = data.error;
                        
                        // Handle specific error types
                        if (data.field === 'points') {
                            errorMsg = `Points validation error: ${data.error}`;
                            if (data.validated_points) {
                                input.value = data.validated_points;
                                errorMsg += ` (Reset to ${data.validated_points})`;
                            }
                        }
                    }
                    
                    // Show detailed error in console for debugging
                    if (data.debug_info) {
                        console.error('[PointsEditor] Debug info:', data.debug_info);
                    }
                    
                    showNotification(`‚ùå ${errorMsg}`, 'error');
                }
                
            } catch (error) {
                console.error('[PointsEditor] Network/parsing error:', error);
                showNotification(`‚ùå Network error updating points: ${error.message}`, 'error');
            } finally {
                // Reset button states
                saveBtn.innerHTML = originalSaveText;
                cancelBtn.innerHTML = originalCancelText;
                saveBtn.disabled = false;
                cancelBtn.disabled = false;
                input.disabled = false;
            }
        });
    });
    
    // Cancel points buttons
    document.querySelectorAll('.cancel-points-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const questionId = this.dataset.questionId;
            const container = this.parentElement.parentElement;
            const input = this.parentElement.querySelector('.points-input');
            const originalValue = input.dataset.originalValue;
            
            // Reset input
            input.value = originalValue;
            
            // Show display, hide edit
            const display = container.querySelector('.question-points-display');
            const editDiv = container.querySelector('.question-points-edit');
            const editBtn = container.querySelector('.edit-points-btn');
            
            display.style.display = 'inline';
            editDiv.style.display = 'none';
            editBtn.style.display = 'inline';
        });
    });
    
    // Allow Enter to save, Escape to cancel
    document.querySelectorAll('.points-input').forEach(input => {
        input.addEventListener('keydown', function(e) {
            const questionId = this.dataset.questionId;
            if (e.key === 'Enter') {
                e.preventDefault();
                document.querySelector(`.save-points-btn[data-question-id="${questionId}"]`).click();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                document.querySelector(`.cancel-points-btn[data-question-id="${questionId}"]`).click();
            }
        });
    });
});

// Warn before leaving with unsaved changes
window.addEventListener('beforeunload', function(e) {
    if (unsavedChanges || changedAudioNames.size > 0) {
        e.preventDefault();
        e.returnValue = '';
    }
});
</script>
{% endblock %}
    
<!-- PDF ROTATION PERSISTENCE DEBUG -->
<script>
console.group('üîç PDF ROTATION PERSISTENCE DEBUG');
console.log('Exam ID:', '{{ exam.id }}');
console.log('Exam Name:', '{{ exam.name }}');
console.log('PDF Rotation:', {{ exam.pdf_rotation|default:0 }});
console.log('Has PDF File:', {% if exam.pdf_file %}true{% else %}false{% endif %});
{% if exam.pdf_file %}
console.log('PDF File Name:', '{{ exam.pdf_file.name }}');
console.log('PDF File URL:', '{{ exam.pdf_file.url }}');
{% endif %}
console.log('Created At:', '{{ exam.created_at|date:"c" }}');
{% if exam.created_by %}
console.log('Created By:', '{{ exam.created_by.name }}');
{% endif %}
console.groupEnd();

{% if not exam.pdf_file %}
console.error('‚ùå PDF ROTATION PERSISTENCE ISSUE DETECTED');
console.error('This exam has rotation settings but no PDF file saved');
console.error('Please check server logs for upload errors');
{% endif %}
</script>
<!-- END PDF ROTATION PERSISTENCE DEBUG -->
